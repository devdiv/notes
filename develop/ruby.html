<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Ruby | School</title>
    <meta name="description" content="测试、开发、读书、分享">
    <link rel="icon" href="/school/favicon.ico">
    
    <link rel="preload" href="/school/assets/css/0.styles.4be495fb.css" as="style"><link rel="preload" href="/school/assets/js/app.5919148e.js" as="script"><link rel="preload" href="/school/assets/js/89.43b51396.js" as="script"><link rel="prefetch" href="/school/assets/js/10.fade4ab6.js"><link rel="prefetch" href="/school/assets/js/100.f1e3a70d.js"><link rel="prefetch" href="/school/assets/js/101.d2d3543e.js"><link rel="prefetch" href="/school/assets/js/102.f8f6d632.js"><link rel="prefetch" href="/school/assets/js/103.90e3bf40.js"><link rel="prefetch" href="/school/assets/js/104.a13bdac5.js"><link rel="prefetch" href="/school/assets/js/105.ac842271.js"><link rel="prefetch" href="/school/assets/js/106.cc5d1227.js"><link rel="prefetch" href="/school/assets/js/107.a0ae32c4.js"><link rel="prefetch" href="/school/assets/js/108.1efce2f1.js"><link rel="prefetch" href="/school/assets/js/109.698e183c.js"><link rel="prefetch" href="/school/assets/js/11.2bd5c48e.js"><link rel="prefetch" href="/school/assets/js/110.1a5da71c.js"><link rel="prefetch" href="/school/assets/js/111.8a5819ae.js"><link rel="prefetch" href="/school/assets/js/112.650a583a.js"><link rel="prefetch" href="/school/assets/js/113.fa08142d.js"><link rel="prefetch" href="/school/assets/js/114.a23e36a1.js"><link rel="prefetch" href="/school/assets/js/115.432e59db.js"><link rel="prefetch" href="/school/assets/js/116.5af50ee5.js"><link rel="prefetch" href="/school/assets/js/117.326216e2.js"><link rel="prefetch" href="/school/assets/js/118.dcf4d7e5.js"><link rel="prefetch" href="/school/assets/js/119.d2995233.js"><link rel="prefetch" href="/school/assets/js/12.e9311be5.js"><link rel="prefetch" href="/school/assets/js/120.391137a1.js"><link rel="prefetch" href="/school/assets/js/121.4436956a.js"><link rel="prefetch" href="/school/assets/js/122.f74e4590.js"><link rel="prefetch" href="/school/assets/js/123.3d8fa706.js"><link rel="prefetch" href="/school/assets/js/124.b34aa8a2.js"><link rel="prefetch" href="/school/assets/js/125.ddf01853.js"><link rel="prefetch" href="/school/assets/js/126.35d0c26a.js"><link rel="prefetch" href="/school/assets/js/127.a40de122.js"><link rel="prefetch" href="/school/assets/js/128.06b91001.js"><link rel="prefetch" href="/school/assets/js/129.15b17132.js"><link rel="prefetch" href="/school/assets/js/13.98cbe429.js"><link rel="prefetch" href="/school/assets/js/130.a0f4d6e0.js"><link rel="prefetch" href="/school/assets/js/131.a717eb4e.js"><link rel="prefetch" href="/school/assets/js/132.849113fe.js"><link rel="prefetch" href="/school/assets/js/133.d18980d1.js"><link rel="prefetch" href="/school/assets/js/134.e89246fc.js"><link rel="prefetch" href="/school/assets/js/135.b2bc455d.js"><link rel="prefetch" href="/school/assets/js/136.45a588ea.js"><link rel="prefetch" href="/school/assets/js/137.0bf37a9b.js"><link rel="prefetch" href="/school/assets/js/138.f029cd36.js"><link rel="prefetch" href="/school/assets/js/139.41233bdd.js"><link rel="prefetch" href="/school/assets/js/14.74114c20.js"><link rel="prefetch" href="/school/assets/js/140.460cae24.js"><link rel="prefetch" href="/school/assets/js/141.d4271585.js"><link rel="prefetch" href="/school/assets/js/142.b589d733.js"><link rel="prefetch" href="/school/assets/js/143.608d8545.js"><link rel="prefetch" href="/school/assets/js/144.cbcac9cf.js"><link rel="prefetch" href="/school/assets/js/145.ea04f41b.js"><link rel="prefetch" href="/school/assets/js/15.a049d4ce.js"><link rel="prefetch" href="/school/assets/js/16.9b4c6ccb.js"><link rel="prefetch" href="/school/assets/js/17.340d1183.js"><link rel="prefetch" href="/school/assets/js/18.4fd81d9b.js"><link rel="prefetch" href="/school/assets/js/19.10c83c8c.js"><link rel="prefetch" href="/school/assets/js/2.22312ed6.js"><link rel="prefetch" href="/school/assets/js/20.27a9629f.js"><link rel="prefetch" href="/school/assets/js/21.00f328b8.js"><link rel="prefetch" href="/school/assets/js/22.246edaaa.js"><link rel="prefetch" href="/school/assets/js/23.569cf05b.js"><link rel="prefetch" href="/school/assets/js/24.b75ec5f9.js"><link rel="prefetch" href="/school/assets/js/25.d9c96029.js"><link rel="prefetch" href="/school/assets/js/26.d2989e35.js"><link rel="prefetch" href="/school/assets/js/27.38bd00fc.js"><link rel="prefetch" href="/school/assets/js/28.bf117d3d.js"><link rel="prefetch" href="/school/assets/js/29.aa663b5e.js"><link rel="prefetch" href="/school/assets/js/3.87a7fe20.js"><link rel="prefetch" href="/school/assets/js/30.4fa409f9.js"><link rel="prefetch" href="/school/assets/js/31.87a58a0d.js"><link rel="prefetch" href="/school/assets/js/32.b7ba24fc.js"><link rel="prefetch" href="/school/assets/js/33.37e4bea3.js"><link rel="prefetch" href="/school/assets/js/34.dcdbe51e.js"><link rel="prefetch" href="/school/assets/js/35.14aa36e0.js"><link rel="prefetch" href="/school/assets/js/36.79d04462.js"><link rel="prefetch" href="/school/assets/js/37.e4ea4dea.js"><link rel="prefetch" href="/school/assets/js/38.a85423a8.js"><link rel="prefetch" href="/school/assets/js/39.c7de24ba.js"><link rel="prefetch" href="/school/assets/js/4.595056df.js"><link rel="prefetch" href="/school/assets/js/40.7d122e75.js"><link rel="prefetch" href="/school/assets/js/41.07c5d7be.js"><link rel="prefetch" href="/school/assets/js/42.5b0ebac0.js"><link rel="prefetch" href="/school/assets/js/43.94fe92ec.js"><link rel="prefetch" href="/school/assets/js/44.4c7bfe54.js"><link rel="prefetch" href="/school/assets/js/45.e4cb3de7.js"><link rel="prefetch" href="/school/assets/js/46.bb278b4a.js"><link rel="prefetch" href="/school/assets/js/47.e76dfb98.js"><link rel="prefetch" href="/school/assets/js/48.b31f649b.js"><link rel="prefetch" href="/school/assets/js/49.e267fd5e.js"><link rel="prefetch" href="/school/assets/js/5.39a214e3.js"><link rel="prefetch" href="/school/assets/js/50.6840fcd0.js"><link rel="prefetch" href="/school/assets/js/51.5745d53f.js"><link rel="prefetch" href="/school/assets/js/52.478a6ddd.js"><link rel="prefetch" href="/school/assets/js/53.44cdfd3f.js"><link rel="prefetch" href="/school/assets/js/54.8a5af591.js"><link rel="prefetch" href="/school/assets/js/55.1a8fdf3e.js"><link rel="prefetch" href="/school/assets/js/56.ecd3e841.js"><link rel="prefetch" href="/school/assets/js/57.fe119433.js"><link rel="prefetch" href="/school/assets/js/58.e6a22b8b.js"><link rel="prefetch" href="/school/assets/js/59.84baf76a.js"><link rel="prefetch" href="/school/assets/js/6.7d46c36f.js"><link rel="prefetch" href="/school/assets/js/60.f908a13b.js"><link rel="prefetch" href="/school/assets/js/61.c7344d3f.js"><link rel="prefetch" href="/school/assets/js/62.c97bc8e3.js"><link rel="prefetch" href="/school/assets/js/63.efbe6fc7.js"><link rel="prefetch" href="/school/assets/js/64.1277d2c7.js"><link rel="prefetch" href="/school/assets/js/65.eb54ca23.js"><link rel="prefetch" href="/school/assets/js/66.0b1ba8bd.js"><link rel="prefetch" href="/school/assets/js/67.385c0c77.js"><link rel="prefetch" href="/school/assets/js/68.4c893e50.js"><link rel="prefetch" href="/school/assets/js/69.12135c2b.js"><link rel="prefetch" href="/school/assets/js/7.744731e1.js"><link rel="prefetch" href="/school/assets/js/70.71c79c5e.js"><link rel="prefetch" href="/school/assets/js/71.72a18539.js"><link rel="prefetch" href="/school/assets/js/72.95e9d83c.js"><link rel="prefetch" href="/school/assets/js/73.90341a68.js"><link rel="prefetch" href="/school/assets/js/74.7972018c.js"><link rel="prefetch" href="/school/assets/js/75.a3483662.js"><link rel="prefetch" href="/school/assets/js/76.ec272a20.js"><link rel="prefetch" href="/school/assets/js/77.63c05270.js"><link rel="prefetch" href="/school/assets/js/78.ea39a90e.js"><link rel="prefetch" href="/school/assets/js/79.bb45e240.js"><link rel="prefetch" href="/school/assets/js/8.ad4334f4.js"><link rel="prefetch" href="/school/assets/js/80.1569ceac.js"><link rel="prefetch" href="/school/assets/js/81.a98852bf.js"><link rel="prefetch" href="/school/assets/js/82.cacaf5de.js"><link rel="prefetch" href="/school/assets/js/83.880176ef.js"><link rel="prefetch" href="/school/assets/js/84.d1bc1585.js"><link rel="prefetch" href="/school/assets/js/85.cee621f6.js"><link rel="prefetch" href="/school/assets/js/86.4b65046f.js"><link rel="prefetch" href="/school/assets/js/87.ed640799.js"><link rel="prefetch" href="/school/assets/js/88.9b6032d2.js"><link rel="prefetch" href="/school/assets/js/9.c996555b.js"><link rel="prefetch" href="/school/assets/js/90.1ea68c22.js"><link rel="prefetch" href="/school/assets/js/91.caec5965.js"><link rel="prefetch" href="/school/assets/js/92.9fadc1eb.js"><link rel="prefetch" href="/school/assets/js/93.948f712f.js"><link rel="prefetch" href="/school/assets/js/94.69a0a901.js"><link rel="prefetch" href="/school/assets/js/95.4d6b9e32.js"><link rel="prefetch" href="/school/assets/js/96.c41dfb08.js"><link rel="prefetch" href="/school/assets/js/97.5980228e.js"><link rel="prefetch" href="/school/assets/js/98.ac37f10d.js"><link rel="prefetch" href="/school/assets/js/99.b762e5e6.js">
    <link rel="stylesheet" href="/school/assets/css/0.styles.4be495fb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/school/" class="home-link router-link-active"><!----> <span class="site-name">School</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/school/" class="nav-link">首页</a></div><div class="nav-item"><a href="/school/website/" class="nav-link">收藏</a></div><div class="nav-item"><a href="/school/tools/" class="nav-link">工具</a></div><div class="nav-item"><a href="/school/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/school/testing/" class="nav-link">测试</a></div><div class="nav-item"><a href="/school/develop/" class="nav-link router-link-active">开发</a></div><div class="nav-item"><a href="/school/blog/" class="nav-link">博客</a></div><div class="nav-item"><a href="/school/reading/" class="nav-link">读书</a></div> <a href="https://github.com/devdiv/school" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/school/" class="nav-link">首页</a></div><div class="nav-item"><a href="/school/website/" class="nav-link">收藏</a></div><div class="nav-item"><a href="/school/tools/" class="nav-link">工具</a></div><div class="nav-item"><a href="/school/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/school/testing/" class="nav-link">测试</a></div><div class="nav-item"><a href="/school/develop/" class="nav-link router-link-active">开发</a></div><div class="nav-item"><a href="/school/blog/" class="nav-link">博客</a></div><div class="nav-item"><a href="/school/reading/" class="nav-link">读书</a></div> <a href="https://github.com/devdiv/school" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>开发</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/school/develop/" class="sidebar-link">前言</a></li><li><a href="/school/develop/Android.html" class="sidebar-link">Android</a></li><li><a href="/school/develop/csharp.html" class="sidebar-link">C Sharp</a></li><li><a href="/school/develop/css.html" class="sidebar-link">CSS</a></li><li><a href="/school/develop/django.html" class="sidebar-link">Django</a></li><li><a href="/school/develop/docker.html" class="sidebar-link">Docker</a></li><li><a href="/school/develop/go.html" class="sidebar-link">Go</a></li><li><a href="/school/develop/Java.html" class="sidebar-link">Java</a></li><li><a href="/school/develop/javascript.html" class="sidebar-link">JavaScript</a></li><li><a href="/school/develop/python.html" class="sidebar-link">Python</a></li><li><a href="/school/develop/Rails.html" class="sidebar-link">Rails</a></li><li><a href="/school/develop/ruby.html" class="active sidebar-link">Ruby</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-开始" class="sidebar-link">Ruby 开始</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-环境" class="sidebar-link">Ruby 环境</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-保留字" class="sidebar-link">Ruby 保留字</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-语句" class="sidebar-link">Ruby 语句</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-变量" class="sidebar-link">Ruby 变量</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-运算符" class="sidebar-link">Ruby 运算符</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-范围（range）" class="sidebar-link">Ruby 范围（Range）</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-字符串（string）" class="sidebar-link">Ruby 字符串（String）</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-数组（array）" class="sidebar-link">Ruby 数组（Array）</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-哈希（hash）" class="sidebar-link">Ruby 哈希（Hash）</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-迭代器" class="sidebar-link">Ruby 迭代器</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-模块" class="sidebar-link">Ruby 模块</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-块" class="sidebar-link">Ruby 块</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-类和对象" class="sidebar-link">Ruby 类和对象</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-方法" class="sidebar-link">Ruby 方法</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-异常" class="sidebar-link">Ruby 异常</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-正则表达式" class="sidebar-link">Ruby 正则表达式</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-日期-时间（date-time）" class="sidebar-link">Ruby 日期 &amp; 时间（Date &amp; Time）</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-文件操作" class="sidebar-link">Ruby 文件操作</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-目录操作" class="sidebar-link">Ruby 目录操作</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-file-类和方法" class="sidebar-link">Ruby File 类和方法</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-dir-类和方法" class="sidebar-link">Ruby Dir 类和方法</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-cgi-编程" class="sidebar-link">Ruby CGI 编程</a></li><li class="sidebar-sub-header"><a href="/school/develop/ruby.html#ruby-编码类型转换" class="sidebar-link">Ruby 编码类型转换</a></li></ul></li><li><a href="/school/develop/vue.html" class="sidebar-link">Vue</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="ruby"><a href="#ruby" class="header-anchor">#</a> Ruby</h1> <p>Ruby 是一种纯粹的面向对象编程语言。它由日本的松本行弘创建于 1993 年。</p> <p>参考:</p> <ul><li><p><a href="http://www.ruby-lang.org/zh_cn/" target="_blank" rel="noopener noreferrer"><strong>Ruby 中文官网</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> - 包含 Ruby 下载、文档、代码库、社区、新闻、安全等方面的详细说明。</p></li> <li><p><a href="http://www.ruby-lang.org/zh_cn/about/" target="_blank" rel="noopener noreferrer"><strong>关于 Ruby</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>- 简单介绍了 Ruby 发展、面向对象、灵活性、块、混入、更多其他特性。</p></li> <li><p><a href="http://www.ruby-lang.org/zh_cn/documentation/ruby-from-other-languages/" target="_blank" rel="noopener noreferrer"><strong>从其它语言转到 Ruby</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> - Ruby 的大部分语法是 Perl、Python 和 Java（以及其他语言）的用户所熟悉的。 如果您曾经使用过这这些语言，学习 Ruby 就是小菜一碟。</p></li> <li><p><a href="https://rubyapi.org/" target="_blank" rel="noopener noreferrer"><strong>RubyAPI.org（英文网站）</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>- 简单搜索浏览 Ruby 类、模块和方法。</p></li> <li><p><a href="https://rubydocs.org/" target="_blank" rel="noopener noreferrer"><strong>Ruby 和 Rails 可检索 API 文档（英文网站）</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>- 可以智能搜索的 Rails 和 Ruby 文档。</p></li> <li><p><a href="https://learncodethehardway.org/ruby/" target="_blank" rel="noopener noreferrer"><strong>笨方法学 Ruby（英文网站）</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>- 一系列非常好的练习，附带讲解，可以指导你从基本的 Ruby 知识一路进阶到面向对象编程和 Web 开发。</p></li> <li><p><a href="http://ruby-doc.com/docs/ProgrammingRuby/" target="_blank" rel="noopener noreferrer"><strong>Programming Ruby（英文网站）</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>- 最有影响的 Ruby 英文教材，Pragmatic Programmers 出版的第一版可以在网上免费阅读。</p></li> <li><p><a href="http://rubylearning.com/" target="_blank" rel="noopener noreferrer"><strong>学习 Ruby（英文网站）</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>- 这里汇集了许多 Ruby 初学者的学习笔记，对 Ruby 的概念和结构有全面的介绍。</p></li></ul> <h2 id="ruby-开始"><a href="#ruby-开始" class="header-anchor">#</a> Ruby 开始</h2> <p>1、中文编码</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby -w</span>
<span class="token comment"># -*- coding: UTF-8 -*-</span>

puts <span class="token string">&quot;你好，世界！&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>注</strong>：Ruby2.0~2.6 版本中文注释有可能需要使用: <code># -*- coding: GBK -*-</code></p> <p>2、注释</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby -w</span>
<span class="token comment"># -*- coding: UTF-8 -*-</span>

<span class="token comment">#这是一个单行注释</span>
<span class="token comment">#a = 3</span>

<span class="token comment">#这是一个多行注释</span>
<span class="token comment">=begin
a = [0,1,2,3]
hashPara = {:name=&gt;&quot;name1&quot;,:number=&gt;&quot;num1&quot;}
=end</span>
</code></pre></div><h2 id="ruby-环境"><a href="#ruby-环境" class="header-anchor">#</a> Ruby 环境</h2> <p>1、Ruby 命令行选项</p> <p>Ruby 一般是从命令行运行，方式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token variable">$ruby</span> <span class="token punctuation">[</span> options <span class="token punctuation">]</span> <span class="token punctuation">[</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span> programfile <span class="token punctuation">]</span> <span class="token punctuation">[</span> arguments <span class="token punctuation">..</span>. <span class="token punctuation">]</span>
</code></pre></div><table><thead><tr><th>选项</th> <th>描述</th></tr></thead> <tbody><tr><td>-a</td> <td>与 -n 或 -p 一起使用时，可以打开自动拆分模式(auto split mode)。请查看 -n 和 -p 选项。</td></tr> <tr><td>-c</td> <td>只检查语法，不执行程序。</td></tr> <tr><td>-C dir</td> <td>在执行前改变目录（等价于 -X）。</td></tr> <tr><td>-d</td> <td>启用调试模式（等价于 -debug）。</td></tr> <tr><td>-F pat</td> <td>指定 pat 作为默认的分离模式（$;）。</td></tr> <tr><td>-e prog</td> <td>指定 prog 作为程序在命令行中执行。可以指定多个 -e 选项，用来执行多个程序。</td></tr> <tr><td>-h</td> <td>显示命令行选项的一个概览。</td></tr> <tr><td>-i [ ext]</td> <td>把文件内容重写为程序输出。原始文件会被加上扩展名 ext 保存下来。如果未指定 ext，原始文件会被删除。</td></tr> <tr><td>-I dir</td> <td>添加 dir 作为加载库的目录。</td></tr> <tr><td>-K [ kcode]</td> <td>指定多字节字符集编码。e 或 E 对应 EUC（extended Unix code），s 或 S 对应 SJIS（Shift-JIS），u 或 U 对应 UTF-8，a、A、n 或 N 对应 ASCII。</td></tr> <tr><td>-l</td> <td>启用自动行尾处理。从输入行取消一个换行符，并向输出行追加一个换行符。</td></tr> <tr><td>-n</td> <td>把代码放置在一个输入循环中（就像在 while gets; ... end 中一样）。</td></tr> <tr><td>-0[ octal]</td> <td>设置默认的记录分隔符（$/）为八进制。如果未指定 octal 则默认为 \0。</td></tr> <tr><td>-p</td> <td>把代码放置在一个输入循环中。在每次迭代后输出变量 $_ 的值。</td></tr> <tr><td>-r lib</td> <td>使用 require 来加载 lib 作为执行前的库。</td></tr> <tr><td>-s</td> <td>解读程序名称和文件名参数之间的匹配模式 -xxx 的任何参数作为开关，并定义相应的变量。</td></tr> <tr><td>-T [level]</td> <td>设置安全级别，执行不纯度测试（如果未指定 level，则默认值为 1）。</td></tr> <tr><td>-v</td> <td>显示版本，并启用冗余模式。</td></tr> <tr><td>-w</td> <td>启用冗余模式。如果未指定程序文件，则从 STDIN 读取。</td></tr> <tr><td>-x [dir]</td> <td>删除 #!ruby 行之前的文本。如果指定了 dir，则把目录改变为 dir。</td></tr> <tr><td>-X dir</td> <td>在执行前改变目录（等价于 -C）。</td></tr> <tr><td>-y</td> <td>启用解析器调试模式。</td></tr> <tr><td>--copyright</td> <td>显示版权声明。</td></tr> <tr><td>--debug</td> <td>启用调试模式（等价于 -d）。</td></tr> <tr><td>--help</td> <td>显示命令行选项的一个概览（等价于 -h）。</td></tr> <tr><td>--version</td> <td>显示版本。</td></tr> <tr><td>--verbose</td> <td>启用冗余模式（等价于 -v）。设置 $VERBOSE 为 true。</td></tr> <tr><td>--yydebug</td> <td>启用解析器调试模式（等价于 -y）。</td></tr></tbody></table> <p>单字符的命令行选项可以组合使用。下面两行表达了同样的意思：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token variable">$ruby</span> -ne <span class="token string">'print if /Ruby/'</span> /usr/share/bin
<span class="token variable">$ruby</span> -n -e <span class="token string">'print if /Ruby/'</span> /usr/share/bin
</code></pre></div><h2 id="ruby-保留字"><a href="#ruby-保留字" class="header-anchor">#</a> Ruby 保留字</h2> <p>下表列出了 Ruby 中的保留字。这些保留字不能作为常量或变量的名称。但是，它们可以作为方法名：</p> <table><thead><tr><th></th> <th></th> <th></th> <th></th></tr></thead> <tbody><tr><td>BEGIN</td> <td>do</td> <td>next</td> <td>then</td></tr> <tr><td>END</td> <td>else</td> <td>nil</td> <td>true</td></tr> <tr><td>alias</td> <td>elsif</td> <td>not</td> <td>undef</td></tr> <tr><td>and</td> <td>end</td> <td>or</td> <td>unless</td></tr> <tr><td>begin</td> <td>ensure</td> <td>redo</td> <td>until</td></tr> <tr><td>break</td> <td>false</td> <td>rescue</td> <td>when</td></tr> <tr><td>case</td> <td>for</td> <td>retry</td> <td>while</td></tr> <tr><td>class</td> <td>if</td> <td>return</td> <td>while</td></tr> <tr><td>def</td> <td>in</td> <td>self</td> <td><strong>FILE</strong></td></tr> <tr><td>defined?</td> <td>module</td> <td>super</td> <td><strong>LINE</strong></td></tr></tbody></table> <h2 id="ruby-语句"><a href="#ruby-语句" class="header-anchor">#</a> Ruby 语句</h2> <p>1、puts/putc/print/gets</p> <table><thead><tr><th>语句</th> <th>说明</th></tr></thead> <tbody><tr><td><code>puts</code></td> <td>语句输出整个字符串到屏幕上，光标会跳到下一行。</td></tr> <tr><td><code>putc</code></td> <td>语句可用于依次输出一个字符。</td></tr> <tr><td><code>print</code></td> <td>语句与 puts 类似，光标定位在同一行。</td></tr></tbody></table> <p>更多请查看 Ruby 的 IO 类。</p> <p>2、if/if...else/unless/case</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">if</span> conditional <span class="token punctuation">[</span><span class="token keyword">then</span><span class="token punctuation">]</span>
      code<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token keyword">elsif</span> conditional <span class="token punctuation">[</span><span class="token keyword">then</span><span class="token punctuation">]</span>
      code<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token keyword">else</span>
      code<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
<span class="token keyword">end</span>

<span class="token keyword">unless</span> conditional <span class="token punctuation">[</span><span class="token keyword">then</span><span class="token punctuation">]</span>
   code
<span class="token punctuation">[</span><span class="token keyword">else</span>
   code <span class="token punctuation">]</span>
<span class="token keyword">end</span>

<span class="token keyword">case</span> expression
<span class="token punctuation">[</span><span class="token keyword">when</span> expression <span class="token punctuation">[</span><span class="token punctuation">,</span> expression <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">then</span><span class="token punctuation">]</span>
   code <span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token keyword">else</span>
   code <span class="token punctuation">]</span>
<span class="token keyword">end</span>
</code></pre></div><p>3、whlie/until/for/break/next/redo</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>
<span class="token comment"># -*- coding: UTF-8 -*-</span>

<span class="token keyword">while</span> conditional <span class="token punctuation">[</span><span class="token keyword">do</span><span class="token punctuation">]</span>
   code
<span class="token keyword">end</span>
<span class="token comment">#或者</span>
<span class="token keyword">while</span> conditional <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
   code
<span class="token keyword">end</span>

<span class="token keyword">until</span> conditional <span class="token punctuation">[</span><span class="token keyword">do</span><span class="token punctuation">]</span>
   code
<span class="token keyword">end</span>

<span class="token keyword">for</span> variable <span class="token punctuation">[</span><span class="token punctuation">,</span> variable <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token keyword">in</span> expression <span class="token punctuation">[</span><span class="token keyword">do</span><span class="token punctuation">]</span>
   code
<span class="token keyword">end</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0.</span><span class="token number">.5</span>
   <span class="token keyword">if</span> i <span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token keyword">then</span>
      <span class="token keyword">break</span>
   <span class="token keyword">end</span>
   puts <span class="token string">&quot;局部变量的值为 <span class="token interpolation"><span class="token delimiter tag">#{</span>i<span class="token delimiter tag">}</span></span>&quot;</span>
<span class="token keyword">end</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0.</span><span class="token number">.5</span>
   <span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token keyword">then</span>
      <span class="token keyword">next</span>
   <span class="token keyword">end</span>
   puts <span class="token string">&quot;局部变量的值为 <span class="token interpolation"><span class="token delimiter tag">#{</span>i<span class="token delimiter tag">}</span></span>&quot;</span>
<span class="token keyword">end</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0.</span><span class="token number">.5</span>
   <span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token keyword">then</span>
      puts <span class="token string">&quot;局部变量的值为 <span class="token interpolation"><span class="token delimiter tag">#{</span>i<span class="token delimiter tag">}</span></span>&quot;</span>
      <span class="token keyword">redo</span>
   <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>4、require 与 include</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment"># require语法</span>
<span class="token keyword">require</span> filename
</code></pre></div><div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment"># 示例</span>
<span class="token comment"># 使用 $LOAD_PATH &lt;&lt; '.' 让 Ruby 知道必须在当前目录中搜索被引用的文件。如果您不想使用 $LOAD_PATH，那么您可以使用 require_relative 来从一个相对目录引用文件。</span>
<span class="token variable">$LOAD_PATH</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">'.'</span>

<span class="token comment"># 文件扩展名 .rb 不是必需的。</span>
<span class="token keyword">require</span> <span class="token string">'trig.rb'</span>
<span class="token keyword">require</span> <span class="token string">'moral'</span>

y <span class="token operator">=</span> <span class="token constant">Trig</span><span class="token punctuation">.</span>sin<span class="token punctuation">(</span><span class="token constant">Trig</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">PI</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span>
x <span class="token operator">=</span> <span class="token constant">Moral</span><span class="token punctuation">.</span>sin<span class="token punctuation">(</span><span class="token constant">Moral</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">VERY_BAD</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>注意：</strong> 文件包含相同的函数名称时，会在引用调用程序时导致代码模糊，但是模块避免了这种代码模糊，而且我们可以使用模块的名称调用适当的函数。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment"># include 语法</span>
<span class="token keyword">include</span> modulename
</code></pre></div><p>如果模块是定义在一个单独的文件中，那么在嵌入模块之前就需要使用 <code>require</code> 语句引用该文件。</p> <p>假设下面的模块写在 session.rb 文件中。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">module</span> <span class="token constant">Session</span>
   <span class="token constant">DEFAULT_SESSION</span> <span class="token operator">=</span> <span class="token constant">Ne</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token constant">Session</span><span class="token punctuation">.</span><span class="token function">get_last_session</span></span>
      puts <span class="token string">&quot;the last session is:&quot;</span>
   <span class="token keyword">end</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token constant">Session</span><span class="token punctuation">.</span><span class="token function">get_current_sesion</span></span>
      puts <span class="token string">&quot;the current session is:&quot;</span>
   <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>
<span class="token variable">$LOAD_PATH</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token string">'.'</span>
<span class="token keyword">require</span> <span class="token string">&quot;Session&quot;</span>

<span class="token keyword">class</span> <span class="token class-name">SessionHandle</span>
<span class="token keyword">include</span> <span class="token constant">Session</span>
   default_session_count <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_session_count</span></span>
      puts <span class="token constant">Session</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">DEFAULT_SESSION</span>
      number<span class="token operator">=</span><span class="token number">10</span><span class="token operator">*</span><span class="token number">12</span>
      puts number
   <span class="token keyword">end</span>
<span class="token keyword">end</span>
sh <span class="token operator">=</span> <span class="token constant">SessionHandle</span><span class="token punctuation">.</span><span class="token keyword">new</span>
puts <span class="token constant">Week</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">FIRST_DAY</span>
<span class="token constant">Week</span><span class="token punctuation">.</span>get_current_sesion
<span class="token constant">Week</span><span class="token punctuation">.</span>get_last_session
sh<span class="token punctuation">.</span>get_session_count
</code></pre></div><p>5、alias 与 undef</p> <p><code>alias</code>用于为方法或全局变量起别名。别名不能在方法主体内定义。即使方法被重写，方法的别名也保持方法的当前定义。</p> <p>为编号的全局变量（$1, $2,...）起别名是被禁止的。重写内置的全局变量可能会导致严重的问题。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">alias</span> 方法名 方法名
<span class="token keyword">alias</span> 全局变量 全局变量
</code></pre></div><div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment"># 示例</span>
<span class="token keyword">alias</span> foo bar <span class="token comment">#为 bar 定义了别名为 foo</span>
<span class="token keyword">alias</span> <span class="token variable">$MATCH</span> $<span class="token operator">&amp;</span> <span class="token comment">#为 $&amp; 定义了别名为 $MATCH</span>
</code></pre></div><p><code>undef</code>用于取消方法定义。<code>undef</code>不能出现在方法主体内。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">undef</span> 方法名
</code></pre></div><div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#示例</span>
<span class="token keyword">undef</span> bar <span class="token comment">#取消名为 bar的方法定义</span>
</code></pre></div><p>通过使用 <code>undef</code> 和 <code>alias</code>，类的接口可以从父类独立修改，但请注意，在自身内部方法调用时，它可能会破坏程序。</p> <p>6、yield</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>
<span class="token comment"># -*- coding: UTF-8 -*-</span>

<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">test</span></span>
   puts <span class="token string">&quot;在 test 方法内&quot;</span>
   <span class="token keyword">yield</span>
   puts <span class="token string">&quot;你又回到了 test 方法内&quot;</span>
   <span class="token keyword">yield</span>
<span class="token keyword">end</span>
test <span class="token punctuation">{</span>puts <span class="token string">&quot;你在块内&quot;</span><span class="token punctuation">}</span>
<span class="token comment">#执行结果为：</span>

<span class="token comment"># 在 test 方法内</span>
<span class="token comment"># 你在块内</span>
<span class="token comment"># 你又回到了 test 方法内</span>
<span class="token comment"># 你在块内</span>
</code></pre></div><div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>
<span class="token comment"># -*- coding: UTF-8 -*-</span>

<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">test</span></span>
   <span class="token keyword">yield</span> <span class="token number">5</span>
   puts <span class="token string">&quot;在 test 方法内&quot;</span>
   <span class="token keyword">yield</span> <span class="token number">100</span> <span class="token comment"># yield 语句后跟着参数</span>
<span class="token keyword">end</span>
test <span class="token punctuation">{</span><span class="token operator">|</span>i<span class="token operator">|</span> puts <span class="token string">&quot;你在块 <span class="token interpolation"><span class="token delimiter tag">#{</span>i<span class="token delimiter tag">}</span></span> 内&quot;</span><span class="token punctuation">}</span>
<span class="token comment"># 执行结果为：</span>
<span class="token comment"># 你在块 5 内</span>
<span class="token comment"># 在 test 方法内</span>
<span class="token comment"># 你在块 100 内</span>
</code></pre></div><p>如果您想使用 <code>yield</code> 语句传递多个参数，使用逗号分隔。如下所示：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#yield后面跟两个参数</span>
<span class="token keyword">yield</span> a<span class="token punctuation">,</span> b
<span class="token comment"># 此时块如下所示：</span>
test <span class="token punctuation">{</span><span class="token operator">|</span>a<span class="token punctuation">,</span> b<span class="token operator">|</span> statement<span class="token punctuation">}</span>
</code></pre></div><h2 id="ruby-变量"><a href="#ruby-变量" class="header-anchor">#</a> Ruby 变量</h2> <p>1、Ruby 变量</p> <p>Ruby 提供了四种类型的变量：</p> <ul><li>局部变量：局部变量是在方法中定义的变量。局部变量在方法外是不可用的。局部变量以小写字母或 <code>_</code> 开始。</li> <li>实例变量：实例变量可以跨任何特定的实例或对象中的方法使用。这意味着，实例变量可以从对象到对象的改变。实例变量在变量名之前放置符号（<code>@</code>）。</li> <li>类变量：类变量可以跨不同的对象使用。类变量属于类，且是类的一个属性。类变量在变量名之前放置符号（<code>@@</code>）。</li> <li>全局变量：类变量不能跨类使用。如果您想要有一个可以跨类使用的变量，您需要定义全局变量。全局变量总是以美元符号（<code>$</code>）开始。</li></ul> <p>2、Ruby 环境变量</p> <p>Ruby 解释器使用下列环境变量来控制它的行为。ENV 对象包含了所有当前设置的环境变量列表。</p> <table><thead><tr><th>变量</th> <th>描述</th></tr></thead> <tbody><tr><td>DLN_LIBRARY_PATH</td> <td>动态加载模块搜索的路径。</td></tr> <tr><td>HOME</td> <td>当没有参数传递给 Dir::chdir 时，要移动到的目录。也用于 File::expand_path 来扩展 &quot;~&quot;。</td></tr> <tr><td>LOGDIR</td> <td>当没有参数传递给 Dir::chdir 且未设置环境变量 HOME 时，要移动到的目录。</td></tr> <tr><td>PATH</td> <td>执行子进程的搜索路径，以及在指定 -S 选项后，Ruby 程序的搜索路径。每个路径用冒号分隔（在 DOS 和 Windows 中用分号分隔）。</td></tr> <tr><td>RUBYLIB</td> <td>库的搜索路径。每个路径用冒号分隔（在 DOS 和 Windows 中用分号分隔）。</td></tr> <tr><td>RUBYLIB_PREFIX</td> <td>用于修改 RUBYLIB 搜索路径，通过使用格式 path1;path2 或 path1path2，把库的前缀 path1 替换为 path2。</td></tr> <tr><td>RUBYOPT</td> <td>传给 Ruby 解释器的命令行选项。在 taint 模式时被忽略（其中，$SAFE 大于 0）。</td></tr> <tr><td>RUBYPATH</td> <td>指定 -S 选项后，Ruby 程序的搜索路径。优先级高于 PATH。在 taint 模式时被忽略（其中，$SAFE 大于 0）。</td></tr> <tr><td>RUBYSHELL</td> <td>指定执行命令时所使用的 shell。如果未设置该环境变量，则使用 SHELL 或 COMSPEC。</td></tr></tbody></table> <p>对于 Unix，使用 <code>env</code> 命令来查看所有环境变量的列表。</p> <h2 id="ruby-运算符"><a href="#ruby-运算符" class="header-anchor">#</a> Ruby 运算符</h2> <p>1、算术运算符</p> <table><thead><tr><th>运算符</th> <th>描述</th> <th>实例</th></tr></thead> <tbody><tr><td>+</td> <td>加法 - 把运算符两边的操作数相加</td> <td>a + b 将得到 30</td></tr> <tr><td>-</td> <td>减法 - 把左操作数减去右操作数</td> <td>a - b 将得到 -10</td></tr> <tr><td>*</td> <td>乘法 - 把运算符两边的操作数相乘</td> <td>a * b 将得到 200</td></tr> <tr><td>/</td> <td>除法 - 把左操作数除以右操作数</td> <td>b / a 将得到 2</td></tr> <tr><td>%</td> <td>求模 - 把左操作数除以右操作数，返回余数</td> <td>b % a 将得到 0</td></tr> <tr><td>**</td> <td>指数 - 执行指数计算</td> <td>a**b 将得到 10 的 20 次方</td></tr></tbody></table> <p>2、比较运算符</p> <table><thead><tr><th>运算符</th> <th>描述</th> <th>实例</th></tr></thead> <tbody><tr><td>==</td> <td>检查两个操作数的值是否相等，如果相等则条件为真。</td> <td>(a == b) 不为真。</td></tr> <tr><td>!=</td> <td>检查两个操作数的值是否相等，如果不相等则条件为真。</td> <td>(a != b) 为真。</td></tr> <tr><td>&gt;</td> <td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td> <td>(a &gt; b) 不为真。</td></tr> <tr><td>&lt;</td> <td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td> <td>(a &lt; b) 为真。</td></tr> <tr><td>&gt;=</td> <td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td> <td>(a &gt;= b) 不为真。</td></tr> <tr><td>&lt;=</td> <td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td> <td>(a &lt;= b) 为真。</td></tr> <tr><td>&lt;=&gt;</td> <td>联合比较运算符。如果第一个操作数等于第二个操作数则返回 0，如果第一个操作数大于第二个操作数则返回 1，如果第一个操作数小于第二个操作数则返回 -1。</td> <td>(a &lt;=&gt; b) 返回 -1。</td></tr> <tr><td>===</td> <td>用于测试 case 语句的 when 子句内的相等。</td> <td>(1...10) === 5 返回 true。</td></tr> <tr><td>.eql?</td> <td>如果接收器和参数具有相同的类型和相等的值，则返回 true。</td> <td>1 == 1.0 返回 true，但是 1.eql?(1.0) 返回 false。</td></tr> <tr><td>equal?</td> <td>如果接收器和参数具有相同的对象 id，则返回 true。</td> <td>如果 aObj 是 bObj 的副本，那么 aObj == bObj 返回 true，a.equal?bObj 返回 false，但是 a.equal?aObj 返回 true。</td></tr></tbody></table> <p>3、赋值运算符</p> <table><thead><tr><th>运算符</th> <th>描述</th> <th>实例</th></tr></thead> <tbody><tr><td>=</td> <td>简单的赋值运算符，把右操作数的值赋给左操作数</td> <td>c = a + b 将把 a + b 的值赋给 c</td></tr> <tr><td>+=</td> <td>加且赋值运算符，把右操作数加上左操作数的结果赋值给左操作数</td> <td>c += a 相当于 c = c + a</td></tr> <tr><td>-=</td> <td>减且赋值运算符，把左操作数减去右操作数的结果赋值给左操作数</td> <td>c -= a 相当于 c = c - a</td></tr> <tr><td>*=</td> <td>乘且赋值运算符，把右操作数乘以左操作数的结果赋值给左操作数</td> <td>c _= a 相当于 c = c _ a</td></tr> <tr><td>/=</td> <td>除且赋值运算符，把左操作数除以右操作数的结果赋值给左操作数</td> <td>c /= a 相当于 c = c / a</td></tr> <tr><td>%=</td> <td>求模且赋值运算符，求两个操作数的模赋值给左操作数</td> <td>c %= a 相当于 c = c % a</td></tr> <tr><td>**=</td> <td>指数且赋值运算符，执行指数计算，并赋值给左操作数</td> <td>c **= a 相当于 c = c ** a</td></tr></tbody></table> <p>Ruby 也支持变量的并行赋值。这使得多个变量可以通过一行的 Ruby 代码进行初始化。例如：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span>
</code></pre></div><p>并行赋值在交换两个变量的值时也很有用：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code>a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> c
</code></pre></div><p>4、位运算符</p> <table><thead><tr><th>运算符</th> <th>描述</th> <th>实例</th></tr></thead> <tbody><tr><td>&amp;</td> <td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td> <td>(a &amp; b) 将得到 12，即为 0000 1100</td></tr> <tr><td></td> <td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td> <td>(a</td></tr> <tr><td>^</td> <td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td> <td>(a ^ b) 将得到 49，即为 0011 0001</td></tr> <tr><td>~</td> <td>二进制补码运算符是一元运算符，具有&quot;翻转&quot;位效果，即 0 变成 1，1 变成 0。</td> <td>(~a ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr> <tr><td>&lt;&lt;</td> <td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td> <td>a &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr> <tr><td>&gt;&gt;</td> <td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td> <td>a &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table> <p>5、逻辑运算符</p> <table><thead><tr><th>运算符</th> <th>描述</th> <th>实例</th></tr></thead> <tbody><tr><td>and</td> <td>称为逻辑与运算符。如果两个操作数都为真，则条件为真。</td> <td>(a and b) 为真。</td></tr> <tr><td>or</td> <td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td> <td>(a or b) 为真。</td></tr> <tr><td>&amp;&amp;</td> <td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td> <td>(a &amp;&amp; b) 为真。</td></tr> <tr><td><code>||</code></td> <td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td> <td>(a</td></tr> <tr><td>!</td> <td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td> <td>!(a &amp;&amp; b) 为假。</td></tr> <tr><td>not</td> <td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td> <td>not(a &amp;&amp; b) 为假。</td></tr></tbody></table> <p>6、三元运算符</p> <table><thead><tr><th>运算符</th> <th>描述</th> <th>实例</th></tr></thead> <tbody><tr><td>? :</td> <td>条件表达式</td> <td>如果条件为真 ? 则值为 X : 否则值为 Y</td></tr></tbody></table> <p>7、范围运算符</p> <table><thead><tr><th>运算符</th> <th>描述</th> <th>实例</th></tr></thead> <tbody><tr><td>..</td> <td>创建一个从开始点到结束点的范围（包含结束点）</td> <td>1..10 创建从 1 到 10 的范围</td></tr> <tr><td>...</td> <td>创建一个从开始点到结束点的范围（不包含结束点）</td> <td>1...10 创建从 1 到 9 的范围</td></tr></tbody></table> <p>8、defined? 运算符</p> <p>defined? 是一个特殊的运算符，以方法调用的形式来判断传递的表达式是否已定义。它返回表达式的描述字符串，如果表达式未定义则返回 nil。</p> <p>下面是 defined? 运算符的各种用法：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code>foo <span class="token operator">=</span> <span class="token number">42</span>
<span class="token keyword">defined</span><span class="token operator">?</span> foo    <span class="token comment"># =&gt; &quot;local-variable&quot;</span>
<span class="token keyword">defined</span><span class="token operator">?</span> <span class="token variable">$_</span>     <span class="token comment"># =&gt; &quot;global-variable&quot;</span>
<span class="token keyword">defined</span><span class="token operator">?</span> bar    <span class="token comment"># =&gt; nil（未定义）</span>

<span class="token keyword">defined</span><span class="token operator">?</span> method_call <span class="token comment"># 如果方法已经定义，则为 True</span>

<span class="token keyword">defined</span><span class="token operator">?</span> puts        <span class="token comment"># =&gt; &quot;method&quot;</span>
<span class="token keyword">defined</span><span class="token operator">?</span> puts<span class="token punctuation">(</span>bar<span class="token punctuation">)</span>   <span class="token comment"># =&gt; nil（在这里 bar 未定义）</span>
<span class="token keyword">defined</span><span class="token operator">?</span> unpack      <span class="token comment"># =&gt; nil（在这里未定义）</span>

<span class="token comment"># 如果存在可被 super 用户调用的方法，则为 True</span>
<span class="token keyword">defined</span><span class="token operator">?</span> <span class="token keyword">super</span>
<span class="token keyword">defined</span><span class="token operator">?</span> <span class="token keyword">super</span>     <span class="token comment"># =&gt; &quot;super&quot;（如果可被调用）</span>
<span class="token keyword">defined</span><span class="token operator">?</span> <span class="token keyword">super</span>     <span class="token comment"># =&gt; nil（如果不可被调用）</span>

<span class="token keyword">defined</span><span class="token operator">?</span> <span class="token keyword">yield</span>   <span class="token comment"># 如果已传递代码块，则为 True</span>
<span class="token keyword">defined</span><span class="token operator">?</span> <span class="token keyword">yield</span>    <span class="token comment"># =&gt; &quot;yield&quot;（如果已传递块）</span>
<span class="token keyword">defined</span><span class="token operator">?</span> <span class="token keyword">yield</span>    <span class="token comment"># =&gt; nil（如果未传递块）</span>
</code></pre></div><p>9、点运算符 &quot;.&quot; 和双冒号运算符 &quot;::&quot;</p> <ul><li>. 来调用类或模块中的方法</li> <li>:: 来引用类或模块中的常量</li></ul> <p><strong>注意</strong> ：在 Ruby 中，类和方法也可以被当作常量。</p> <p>你只需要在表达式的常量名前加上 :: 前缀，即可返回适当的类或模块对象。</p> <p>如果 :: 前的表达式为类或模块名称，则返回该类或模块内对应的常量值；如果 :: 前未没有前缀表达式，则返回主 Object 类中对应的常量值。</p> <p>10、运算符的优先级</p> <table><thead><tr><th>方法</th> <th>运算符</th> <th>描述</th></tr></thead> <tbody><tr><td>是</td> <td>::</td> <td>常量解析运算符</td></tr> <tr><td>是</td> <td>[ ][ ]=</td> <td>元素引用、元素集合</td></tr> <tr><td>是</td> <td>**</td> <td>指数</td></tr> <tr><td>是</td> <td>! ~ + -</td> <td>非、补、一元加、一元减（最后两个的方法名为 +@ 和 -@）</td></tr> <tr><td>是</td> <td>* / %</td> <td>乘法、除法、求模</td></tr> <tr><td>是</td> <td>+ -</td> <td>加法和减法</td></tr> <tr><td>是</td> <td>&gt;&gt; &lt;&lt;</td> <td>位右移、位左移</td></tr> <tr><td>是</td> <td>&amp;</td> <td>位与</td></tr> <tr><td>是</td> <td>^</td> <td></td></tr> <tr><td>是</td> <td>&lt;= &lt; &gt; &gt;=</td> <td>比较运算符</td></tr> <tr><td>是</td> <td>&lt;=&gt; == === != =~ !~</td> <td>相等和模式匹配运算符（!= 和 !~ 不能被定义为方法）</td></tr> <tr><td>-</td> <td>&amp;&amp;</td> <td>逻辑与</td></tr> <tr><td>-</td> <td><code>||</code></td> <td>逻辑或</td></tr> <tr><td>-</td> <td>.. ...</td> <td>范围（包含、不包含）</td></tr> <tr><td>-</td> <td>? :</td> <td>三元 if-then-else</td></tr> <tr><td>-</td> <td>= %= { /= -= +=</td> <td>= &amp;= &gt;&gt;= &lt;&lt;= *= &amp;&amp;=</td></tr> <tr><td>-</td> <td>defined?</td> <td>检查指定符号是否已定义</td></tr> <tr><td>-</td> <td>not</td> <td>逻辑否定</td></tr> <tr><td>-</td> <td>or and</td> <td>逻辑组成</td></tr></tbody></table> <p><strong>注</strong>：在方法列标识为 是 的运算符实际上是方法，因此可以被重载。</p> <h2 id="ruby-范围（range）"><a href="#ruby-范围（range）" class="header-anchor">#</a> Ruby 范围（Range）</h2> <p>1、序列检查</p> <p>范围的第一个也是最常见的用途是表达序列。序列有一个起点、一个终点和一个在序列产生连续值的方式。</p> <p>Ruby 使用 ''..'' 和 ''...'' 范围运算符创建这些序列。两点形式创建一个包含指定的最高值的范围，三点形式创建一个不包含指定的最高值的范围。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>
<span class="token punctuation">(</span><span class="token number">1.</span><span class="token number">.5</span><span class="token punctuation">)</span>        <span class="token comment">#==&gt; 1, 2, 3, 4, 5</span>
<span class="token punctuation">(</span><span class="token number">1.</span><span class="token punctuation">.</span><span class="token number">.5</span><span class="token punctuation">)</span>       <span class="token comment">#==&gt; 1, 2, 3, 4</span>
<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token string">'d'</span><span class="token punctuation">)</span>    <span class="token comment">#==&gt; 'a', 'b', 'c', 'd'</span>
<span class="token punctuation">(</span><span class="token number">1.</span><span class="token number">.10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_a  <span class="token comment">#==&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token string">'bat'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_a <span class="token comment">#==&gt; [&quot;bar&quot;, &quot;bas&quot;, &quot;bat&quot;]</span>
</code></pre></div><p>序列检查：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>
<span class="token comment"># -*- coding: UTF-8 -*-</span>

<span class="token comment"># 指定范围</span>
digits <span class="token operator">=</span> <span class="token number">0.</span><span class="token number">.9</span>

puts digits<span class="token punctuation">.</span><span class="token keyword">include</span><span class="token operator">?</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
ret <span class="token operator">=</span> digits<span class="token punctuation">.</span>min
puts <span class="token string">&quot;最小值为 <span class="token interpolation"><span class="token delimiter tag">#{</span>ret<span class="token delimiter tag">}</span></span>&quot;</span>

ret <span class="token operator">=</span> digits<span class="token punctuation">.</span>max
puts <span class="token string">&quot;最大值为 <span class="token interpolation"><span class="token delimiter tag">#{</span>ret<span class="token delimiter tag">}</span></span>&quot;</span>

ret <span class="token operator">=</span> digits<span class="token punctuation">.</span>reject <span class="token punctuation">{</span><span class="token operator">|</span>i<span class="token operator">|</span> i <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token punctuation">}</span>
puts <span class="token string">&quot;不符合条件的有 <span class="token interpolation"><span class="token delimiter tag">#{</span>ret<span class="token delimiter tag">}</span></span>&quot;</span>

digits<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>digit<span class="token operator">|</span>
   puts <span class="token string">&quot;在循环中 <span class="token interpolation"><span class="token delimiter tag">#{</span>digit<span class="token delimiter tag">}</span></span>&quot;</span>
<span class="token keyword">end</span>
</code></pre></div><p>2、条件检查</p> <p>范围也可以用作条件表达式。例如，下面的代码片段从标准输入打印行，其中每个集合的第一行包含单词 start，最后一行包含单词 end.：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">while</span> gets
   print <span class="token keyword">if</span> <span class="token regex">/start/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token regex">/end/</span>
<span class="token keyword">end</span>
</code></pre></div><div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>
<span class="token comment"># -*- coding: UTF-8 -*-</span>

score <span class="token operator">=</span> <span class="token number">70</span>

result <span class="token operator">=</span> <span class="token keyword">case</span> score
<span class="token keyword">when</span> <span class="token number">0.</span><span class="token number">.60</span>
    <span class="token string">&quot;Bad&quot;</span>
<span class="token keyword">when</span> <span class="token number">61.</span><span class="token number">.80</span>
    <span class="token string">&quot;Not Bad&quot;</span>
<span class="token keyword">when</span> <span class="token number">81.</span><span class="token number">.100</span>
    <span class="token string">&quot;Good&quot;</span>
<span class="token keyword">else</span>
    <span class="token string">&quot;Wrong Number&quot;</span>
<span class="token keyword">end</span>

puts result  <span class="token comment">#==&gt; Not Bad</span>
</code></pre></div><p>3、间隔检查</p> <p>检查指定值是否在指定的范围内。需要使用 === 相等运算符来完成计算。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>
<span class="token comment"># -*- coding: UTF-8 -*-</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1.</span><span class="token number">.10</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">5</span><span class="token punctuation">)</span>
  puts <span class="token string">&quot;5 在 (1..10)&quot;</span>
<span class="token keyword">end</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token string">'j'</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'c'</span><span class="token punctuation">)</span>
  puts <span class="token string">&quot;c 在 ('a'..'j')&quot;</span>
<span class="token keyword">end</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token string">'j'</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'z'</span><span class="token punctuation">)</span>
  puts <span class="token string">&quot;z 在 ('a'..'j')&quot;</span>
<span class="token keyword">end</span>
</code></pre></div><h2 id="ruby-字符串（string）"><a href="#ruby-字符串（string）" class="header-anchor">#</a> Ruby 字符串（String）</h2> <p>Ruby 中的 String 对象用于存储或操作一个或多个字节的序列。</p> <p>Ruby 字符串分为单引号字符串（'）和双引号字符串（&quot;），区别在于双引号字符串能够支持更多的转义字符。</p> <p>1、转义字符</p> <p>下标列出了可使用反斜杠符号转义的转义字符或非打印字符。</p> <p><strong>注</strong>：在一个双引号括起的字符串内，转义字符会被解析。在一个单引号括起的字符串内，转义字符不会被解析，原样输出。</p> <table><thead><tr><th>反斜杠符号</th> <th>十六进制字符</th> <th>描述</th></tr></thead> <tbody><tr><td>\a</td> <td>0x07</td> <td>报警符</td></tr> <tr><td>\b</td> <td>0x08</td> <td>退格键</td></tr> <tr><td>\cx</td> <td></td> <td>Control-x</td></tr> <tr><td>\C-x</td> <td></td> <td>Control-x</td></tr> <tr><td>\e</td> <td>0x1b</td> <td>转义符</td></tr> <tr><td>\f</td> <td>0x0c</td> <td>换页符</td></tr> <tr><td>\M-\C-x</td> <td></td> <td>Meta-Control-x</td></tr> <tr><td>\n</td> <td>0x0a</td> <td>换行符</td></tr> <tr><td>\nnn</td> <td></td> <td>八进制表示法，其中 n 的范围为 0.7</td></tr> <tr><td>\r</td> <td>0x0d</td> <td>回车符</td></tr> <tr><td>\s</td> <td>0x20</td> <td>空格符</td></tr> <tr><td>\t</td> <td>0x09</td> <td>制表符</td></tr> <tr><td>\v</td> <td>0x0b</td> <td>垂直制表符</td></tr> <tr><td>\x</td> <td></td> <td>字符 x</td></tr> <tr><td>\xnn</td> <td></td> <td>十六进制表示法，其中 n 的范围为 0.9、 a.f 或 A.F</td></tr></tbody></table> <p>2、字符编码</p> <p>Ruby 的默认字符集是 ASCII，字符可用单个字节表示。如果您使用 UTF-8 或其他现代的字符集，字符可能是用一个到四个字节表示。</p> <p>您可以在程序开头使用 $KCODE 改变字符集，如下所示：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token variable">$KCODE</span> <span class="token operator">=</span> <span class="token string">'u'</span>
</code></pre></div><p>下面是 $KCODE 可能的值。</p> <table><thead><tr><th>编码</th> <th>描述</th></tr></thead> <tbody><tr><td>a</td> <td>ASCII （与 none 相同）。这是默认的。</td></tr> <tr><td>e</td> <td>EUC。</td></tr> <tr><td>n</td> <td>None （与 ASCII 相同）。</td></tr> <tr><td>u</td> <td>UTF-8。</td></tr></tbody></table> <p>3、字符串内建方法</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">new</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>str<span class="token operator">=</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre></div><p>这将返回一个包含 str 副本的新的字符串对象。现在，使用 str 对象，我们可以调用任意可用的实例方法。例如：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>

myStr <span class="token operator">=</span> <span class="token builtin">String</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">&quot;THIS IS TEST&quot;</span><span class="token punctuation">)</span>
foo <span class="token operator">=</span> myStr<span class="token punctuation">.</span>downcase

puts <span class="token string">&quot;<span class="token interpolation"><span class="token delimiter tag">#{</span>foo<span class="token delimiter tag">}</span></span>&quot;</span>
</code></pre></div><p>下面是公共的字符串方法（假设 str 是一个 String 对象）：</p> <table><thead><tr><th>序号</th> <th>方法</th> <th>描述</th></tr></thead> <tbody><tr><td>1</td> <td><code>str % arg</code></td> <td>使用格式规范格式化字符串。如果 arg 包含一个以上的替代，那么 arg 必须是一个数组。如需了解更多格式规范的信息，请查看&quot;内核模块&quot;下的 sprintf。</td></tr> <tr><td>2</td> <td><code>str * integer</code></td> <td>返回一个包含 integer 个 str 的新的字符串。换句话说，str 被重复了 integer 次。</td></tr> <tr><td>3</td> <td><code>str + other_str</code></td> <td>连接 other_str 到 str。</td></tr> <tr><td>4</td> <td><code>str &lt;&lt; obj</code></td> <td>连接一个对象到字符串。如果对象是范围为 0.255 之间的固定数字 Fixnum，则它会被转换为一个字符。把它与 concat 进行比较。</td></tr> <tr><td>5</td> <td><code>str &lt;=&gt; other_str</code></td> <td>把 str 与 other_str 进行比较，返回 -1（小于）、0（等于）或 1（大于）。比较是区分大小写的。</td></tr> <tr><td>6</td> <td><code>str == obj</code></td> <td>检查 str 和 obj 的相等性。如果 obj 不是字符串，则返回 false，如果 str &lt;=&gt; obj，则返回 true，返回 0。</td></tr> <tr><td>7</td> <td><code>str =~ obj</code></td> <td>根据正则表达式模式 obj 匹配 str。返回匹配开始的位置，否则返回 false。</td></tr> <tr><td>8</td> <td><code>str[position] str[start, length] str[start..end] str[start...end]</code></td> <td>str[position] # 注意返回的是 ASCII 码而不是字符。使用索引截取子串</td></tr> <tr><td>9</td> <td><code>str.capitalize</code></td> <td>把字符串转换为大写字母显示。</td></tr> <tr><td>10</td> <td><code>str.capitalize!</code></td> <td>与 capitalize 相同，但是 str 会发生变化并返回。</td></tr> <tr><td>11</td> <td><code>str.casecmp</code></td> <td>不区分大小写的字符串比较。</td></tr> <tr><td>12</td> <td><code>str.center</code></td> <td>居中字符串。</td></tr> <tr><td>13</td> <td><code>str.chomp</code></td> <td>从字符串末尾移除记录分隔符（$/），通常是 \n。如果没有记录分隔符，则不进行任何操作。</td></tr> <tr><td>14</td> <td><code>str.chomp!</code></td> <td>与 chomp 相同，但是 str 会发生变化并返回。</td></tr> <tr><td>15</td> <td><code>str.chop</code></td> <td>移除 str 中的最后一个字符。</td></tr> <tr><td>16</td> <td><code>str.chop!</code></td> <td>与 chop 相同，但是 str 会发生变化并返回。</td></tr> <tr><td>17</td> <td><code>str.concat(other_str)</code></td> <td>连接 other_str 到 str。</td></tr> <tr><td>18</td> <td><code>str.count(str, ...)</code></td> <td>给一个或多个字符集计数。如果有多个字符集，则给这些集合的交集计数。</td></tr> <tr><td>19</td> <td><code>str.crypt(other_str)</code></td> <td>对 str 应用单向加密哈希。参数是两个字符长的字符串，每个字符的范围为 a.z、 A.Z、 0.9、 . 或 /。</td></tr> <tr><td>20</td> <td><code>str.delete(other_str, ...)</code></td> <td>返回 str 的副本，参数交集中的所有字符会被删除。</td></tr> <tr><td>21</td> <td><code>str.delete!(other_str, ...)</code></td> <td>与 delete 相同，但是 str 会发生变化并返回。</td></tr> <tr><td>22</td> <td><code>str.downcase</code></td> <td>返回 str 的副本，所有的大写字母会被替换为小写字母。</td></tr> <tr><td>23</td> <td><code>str.downcase!</code></td> <td>与 downcase 相同，但是 str 会发生变化并返回。</td></tr> <tr><td>24</td> <td><code>str.dump</code></td> <td>返回 str 的版本，所有的非打印字符被替换为 \nnn 符号，所有的特殊字符被转义。</td></tr> <tr><td>25</td> <td><code>str.each(separator=$/) { |substr| block }</code></td> <td>使用参数作为记录分隔符（默认是 $/）分隔 str，传递每个子字符串给被提供的块。</td></tr> <tr><td>26</td> <td><code>str.each_byte { |fixnum| block }</code></td> <td>传递 str 的每个字节给 block，以字节的十进制表示法返回每个字节。</td></tr> <tr><td>27</td> <td><code>str.each_line(separator=$/) { |substr| block }</code></td> <td>使用参数作为记录分隔符（默认是 $/）分隔 str，传递每个子字符串给被提供的 block。</td></tr> <tr><td>28</td> <td><code>str.empty?</code></td> <td>如果 str 为空（即长度为 0），则返回 true。</td></tr> <tr><td>29</td> <td><code>str.eql?(other)</code></td> <td>如果两个字符串有相同的长度和内容，则这两个字符串相等。</td></tr> <tr><td>30</td> <td><code>str.gsub(pattern, replacement) [or]str.gsub(pattern) { |match| block }</code></td> <td>返回 str 的副本，pattern 的所有出现都替换为 replacement 或 block 的值。pattern 通常是一个正则表达式 Regexp；如果是一个字符串 String，则没有正则表达式元字符被解释（即，/\d/ 将匹配一个数字，但 '\d' 将匹配一个反斜杠后跟一个 'd'）。</td></tr> <tr><td>31</td> <td><code>str[fixnum] [or] str[fixnum,fixnum] [or] str[range] [or] str[regexp] [or] str[regexp, fixnum] [or] str[other_str]</code></td> <td>使用下列的参数引用 str：参数为一个 Fixnum，则返回 fixnum 的字符编码；参数为两个 Fixnum，则返回一个从偏移（第一个 fixnum）开始截至到长度（第二个 fixnum）为止的子字符串；参数为 range，则返回该范围内的一个子字符串；参数为 regexp，则返回匹配字符串的部分；参数为带有 fixnum 的 regexp，则返回 fixnum 位置的匹配数据；参数为 other_str，则返回匹配 other_str 的子字符串。一个负数的 Fixnum 从字符串的末尾 -1 开始。</td></tr> <tr><td>32</td> <td><code>str[fixnum] = fixnum [or] str[fixnum] = new_str [or] str[fixnum, fixnum] = new_str [or] str[range] = aString [or] str[regexp] =new_str [or] str[regexp, fixnum] =new_str [or] str[other_str] = new_str ]</code></td> <td>替换整个字符串或部分字符串。与 slice! 同义。</td></tr> <tr><td>33</td> <td><code>str.gsub!(pattern, replacement) [or] str.gsub!(pattern) { |match| block }</code></td> <td>执行 String#gsub 的替换，返回 str，如果没有替换被执行则返回 nil。</td></tr> <tr><td>34</td> <td><code>str.hash</code></td> <td>返回一个基于字符串长度和内容的哈希。</td></tr> <tr><td>35</td> <td><code>str.hex</code></td> <td>把 str 的前导字符当作十六进制数字的字符串（一个可选的符号和一个可选的 0x），并返回相对应的数字。如果错误则返回零。</td></tr> <tr><td>36</td> <td><code>str.include? other_str [or] str.include? fixnum</code></td> <td>如果 str 包含给定的字符串或字符，则返回 true。</td></tr> <tr><td>37</td> <td><code>str.index(substring [, offset]) [or] str.index(fixnum [, offset]) [or]str.index(regexp [, offset])</code></td> <td>返回给定子字符串、字符（fixnum）或模式（regexp）在 str 中第一次出现的索引。如果未找到则返回 nil。如果提供了第二个参数，则指定在字符串中开始搜索的位置。</td></tr> <tr><td>38</td> <td><code>str.insert(index, other_str)</code></td> <td>在给定索引的字符前插入 other_str，修改 str。负值索引从字符串的末尾开始计数，并在给定字符后插入。其意图是在给定的索引处开始插入一个字符串。</td></tr> <tr><td>39</td> <td><code>str.inspect</code></td> <td>返回 str 的可打印版本，带有转义的特殊字符。</td></tr> <tr><td>40</td> <td><code>str.intern [or] str.to_sym</code></td> <td>返回与 str 相对应的符号，如果之前不存在，则创建符号。</td></tr> <tr><td>41</td> <td><code>str.length</code></td> <td>返回 str 的长度。把它与 size 进行比较。</td></tr> <tr><td>42</td> <td><code>str.ljust(integer, padstr=' ')</code></td> <td>如果 integer 大于 str 的长度，则返回长度为 integer 的新字符串，新字符串以 str 左对齐，并以 padstr 作为填充。否则，返回 str。</td></tr> <tr><td>43</td> <td><code>str.lstrip</code></td> <td>返回 str 的副本，移除了前导的空格。</td></tr> <tr><td>44</td> <td><code>str.lstrip!</code></td> <td>从 str 中移除前导的空格，如果没有变化则返回 nil。</td></tr> <tr><td>45</td> <td><code>str.match(pattern)</code></td> <td>如果 pattern 不是正则表达式，则把 pattern 转换为正则表达式 Regexp，然后在 str 上调用它的匹配方法。</td></tr> <tr><td>46</td> <td><code>str.oct</code></td> <td>把 str 的前导字符当作十进制数字的字符串（一个可选的符号），并返回相对应的数字。如果转换失败，则返回 0。</td></tr> <tr><td>47</td> <td><code>str.replace(other_str)</code></td> <td>把 str 中的内容替换为 other_str 中的相对应的值。</td></tr> <tr><td>48</td> <td><code>str.reverse</code></td> <td>返回一个新字符串，新字符串是 str 的倒序。</td></tr> <tr><td>49</td> <td><code>str.reverse!</code></td> <td>逆转 str，str 会发生变化并返回。</td></tr> <tr><td>50</td> <td><code>str.rindex(substring [, fixnum]) [or]str.rindex(fixnum [, fixnum]) [or]str.rindex(regexp [, fixnum])</code></td> <td>返回给定子字符串、字符（fixnum）或模式（regexp）在 str 中最后一次出现的索引。如果未找到则返回 nil。如果提供了第二个参数，则指定在字符串中结束搜索的位置。超出该点的字符将不被考虑。</td></tr> <tr><td>51</td> <td><code>str.rjust(integer, padstr=' ')</code></td> <td>如果 integer 大于 str 的长度，则返回长度为 integer 的新字符串，新字符串以 str 右对齐，并以 padstr 作为填充。否则，返回 str。</td></tr> <tr><td>52</td> <td><code>str.rstrip</code></td> <td>返回 str 的副本，移除了尾随的空格。</td></tr> <tr><td>53</td> <td><code>str.rstrip!</code></td> <td>从 str 中移除尾随的空格，如果没有变化则返回 nil。</td></tr> <tr><td>54</td> <td><code>str.scan(pattern) [or]str.scan(pattern) { |match, ...| block }</code></td> <td>两种形式匹配 pattern（可以是一个正则表达式 Regexp 或一个字符串 String）遍历 str。针对每个匹配，会生成一个结果，结果会添加到结果数组中或传递给 block。如果 pattern 不包含分组，则每个独立的结果由匹配的字符串、$&amp; 组成。如果 pattern 包含分组，每个独立的结果是一个包含每个分组入口的数组。</td></tr> <tr><td>55</td> <td><code>str.slice(fixnum) [or] str.slice(fixnum, fixnum) [or]str.slice(range) [or] str.slice(regexp) [or]str.slice(regexp, fixnum) [or] str.slice(other_str)See str[fixnum], etc.str.slice!(fixnum) [or] str.slice!(fixnum, fixnum) [or] str.slice!(range) [or] str.slice!(regexp) [or] str.slice!(other_str)</code></td> <td>从 str 中删除指定的部分，并返回删除的部分。如果值超出范围，参数带有 Fixnum 的形式，将生成一个 IndexError。参数为 range 的形式，将生成一个 RangeError，参数为 Regexp 和 String 的形式，将忽略执行动作。</td></tr> <tr><td>56</td> <td><code>str.split(pattern=$;, [limit])</code></td> <td>基于分隔符，把 str 分成子字符串，并返回这些子字符串的数组。如果 pattern 是一个字符串 String，那么在分割 str 时，它将作为分隔符使用。如果 pattern 是一个单一的空格，那么 str 是基于空格进行分割，会忽略前导空格和连续空格字符。如果 pattern 是一个正则表达式 Regexp，则 str 在 pattern 匹配的地方被分割。当 pattern 匹配一个零长度的字符串时，str 被分割成单个字符。如果省略了 pattern 参数，则使用 $; 的值。如果 $; 为 nil（默认的），str 基于空格进行分割，就像是指定了 `` 作为分隔符一样。如果省略了 limit 参数，会抑制尾随的 null 字段。如果 limit 是一个正数，则最多返回该数量的字段（如果 limit 为 1，则返回整个字符串作为数组中的唯一入口）。如果 limit 是一个负数，则返回的字段数量不限制，且不抑制尾随的 null 字段。</td></tr> <tr><td>57</td> <td><code>str.squeeze([other_str]*)</code></td> <td>使用为 String#count 描述的程序从 other_str 参数建立一系列字符。返回一个新的字符串，其中集合中出现的相同的字符会被替换为单个字符。如果没有给出参数，则所有相同的字符都被替换为单个字符。</td></tr> <tr><td>58</td> <td><code>str.squeeze!([other_str]*)</code></td> <td>与 squeeze 相同，但是 str 会发生变化并返回，如果没有变化则返回 nil。</td></tr> <tr><td>59</td> <td><code>str.strip</code></td> <td>返回 str 的副本，移除了前导的空格和尾随的空格。</td></tr> <tr><td>60</td> <td><code>str.strip!</code></td> <td>从 str 中移除前导的空格和尾随的空格，如果没有变化则返回 nil。</td></tr> <tr><td>61</td> <td><code>str.sub(pattern, replacement) [or]str.sub(pattern) { |match| block }</code></td> <td>返回 str 的副本，pattern 的第一次出现会被替换为 replacement 或 block 的值。pattern 通常是一个正则表达式 Regexp；如果是一个字符串 String，则没有正则表达式元字符被解释。</td></tr> <tr><td>62</td> <td><code>str.sub!(pattern, replacement) [or]str.sub!(pattern) { |match| block }</code></td> <td>执行 String#sub 替换，并返回 str，如果没有替换执行，则返回 nil。</td></tr> <tr><td>63</td> <td><code>str.succ [or] str.next</code></td> <td>返回 str 的继承。</td></tr> <tr><td>64</td> <td><code>str.succ! [or] str.next!</code></td> <td>相当于 String#succ，但是 str 会发生变化并返回。</td></tr> <tr><td>65</td> <td><code>str.sum(n=16)</code></td> <td>返回 str 中字符的 n-bit 校验和，其中 n 是可选的 Fixnum 参数，默认为 16。结果是简单地把 str 中每个字符的二进制值的总和，以 2n - 1 为模。这不是一个特别好的校验和。</td></tr> <tr><td>66</td> <td><code>str.swapcase</code></td> <td>返回 str 的副本，所有的大写字母转换为小写字母，所有的小写字母转换为大写字母。</td></tr> <tr><td>67</td> <td><code>str.swapcase!</code></td> <td>相当于 String#swapcase，但是 str 会发生变化并返回，如果没有变化则返回 nil。</td></tr> <tr><td>68</td> <td><code>str.to_f</code></td> <td>返回把 str 中的前导字符解释为浮点数的结果。超出有效数字的末尾的多余字符会被忽略。如果在 str 的开头没有有效数字，则返回 0.0。该方法不会生成异常。</td></tr> <tr><td>69</td> <td><code>str.to_i(base=10)</code></td> <td>返回把 str 中的前导字符解释为整数基数（基数为 2、 8、 10 或 16）的结果。超出有效数字的末尾的多余字符会被忽略。如果在 str 的开头没有有效数字，则返回 0。该方法不会生成异常。</td></tr> <tr><td>70</td> <td><code>str.to_s [or] str.to_str</code></td> <td>返回接收的值。</td></tr> <tr><td>71</td> <td><code>str.tr(from_str, to_str)</code></td> <td>返回 str 的副本，把 from_str 中的字符替换为 to_str 中相对应的字符。如果 to_str 比 from_str 短，那么它会以最后一个字符进行填充。两个字符串都可以使用 c1.c2 符号表示字符的范围。如果 from_str 以 ^ 开头，则表示除了所列出的字符以外的所有字符。</td></tr> <tr><td>72</td> <td><code>str.tr!(from_str, to_str)</code></td> <td>相当于 String#tr，但是 str 会发生变化并返回，如果没有变化则返回 nil。</td></tr> <tr><td>73</td> <td><code>str.tr_s(from_str, to_str)</code></td> <td>把 str 按照 String#tr 描述的规则进行处理，然后移除会影响翻译的重复字符。</td></tr> <tr><td>74</td> <td><code>str.tr_s!(from_str, to_str)</code></td> <td>相当于 String#tr_s，但是 str 会发生变化并返回，如果没有变化则返回 nil。</td></tr> <tr><td>75</td> <td><code>str.unpack(format)</code></td> <td>根据 format 字符串解码 str（可能包含二进制数据），返回被提取的每个值的数组。format 字符由一系列单字符指令组成。每个指令后可以跟着一个数字，表示重复该指令的次数。星号（*）将使用所有剩余的元素。指令 sSiIlL 每个后可能都跟着一个下划线（_），为指定类型使用底层平台的本地尺寸大小，否则使用独立于平台的一致的尺寸大小。format 字符串中的空格会被忽略。</td></tr> <tr><td>76</td> <td><code>str.upcase</code></td> <td>返回 str 的副本，所有的小写字母会被替换为大写字母。操作是环境不敏感的，只有字符 a 到 z 会受影响。</td></tr> <tr><td>77</td> <td><code>str.upcase!</code></td> <td>改变 str 的内容为大写，如果没有变化则返回 nil。</td></tr> <tr><td>78</td> <td><code>str.upto(other_str) { |s| block }</code></td> <td>遍历连续值，以 str 开始，以 other_str 结束（包含），轮流传递每个值给 block。String#succ 方法用于生成每个值。</td></tr></tbody></table> <p>4、字符串 unpack 指令</p> <table><thead><tr><th>指令</th> <th>返回</th> <th>描述</th></tr></thead> <tbody><tr><td>A</td> <td>String</td> <td>移除尾随的 null 和空格。</td></tr> <tr><td>a</td> <td>String</td> <td>字符串。</td></tr> <tr><td>B</td> <td>String</td> <td>从每个字符中提取位（首先是最高有效位）。</td></tr> <tr><td>b</td> <td>String</td> <td>从每个字符中提取位（首先是最低有效位）。</td></tr> <tr><td>C</td> <td>Fixnum</td> <td>提取一个字符作为无符号整数。</td></tr> <tr><td>c</td> <td>Fixnum</td> <td>提取一个字符作为整数。</td></tr> <tr><td>D, d</td> <td>Float</td> <td>把 sizeof(double) 长度的字符当作原生的 double。</td></tr> <tr><td>E</td> <td>Float</td> <td>把 sizeof(double) 长度的字符当作 littleendian 字节顺序的 double。</td></tr> <tr><td>e</td> <td>Float</td> <td>把 sizeof(float) 长度的字符当作 littleendian 字节顺序的 float。</td></tr> <tr><td>F, f</td> <td>Float</td> <td>把 sizeof(float) 长度的字符当作原生的 float。</td></tr> <tr><td>G</td> <td>Float</td> <td>把 sizeof(double) 长度的字符当作 network 字节顺序的 double。</td></tr> <tr><td>g</td> <td>Float</td> <td>把 sizeof(float) 长度的字符当作 network 字节顺序的 float。</td></tr> <tr><td>H</td> <td>String</td> <td>从每个字符中提取十六进制（首先是最高有效位）。</td></tr> <tr><td>h</td> <td>String</td> <td>从每个字符中提取十六进制（首先是最低有效位）。</td></tr> <tr><td>I</td> <td>Integer</td> <td>把 sizeof(int) 长度（通过 _ 修改）的连续字符当作原生的 integer。</td></tr> <tr><td>i</td> <td>Integer</td> <td>把 sizeof(int) 长度（通过 _ 修改）的连续字符当作有符号的原生的 integer。</td></tr> <tr><td>L</td> <td>Integer</td> <td>把四个（通过 _ 修改）连续字符当作无符号的原生的 long integer。</td></tr> <tr><td>l</td> <td>Integer</td> <td>把四个（通过 _ 修改）连续字符当作有符号的原生的 long integer。</td></tr> <tr><td>M</td> <td>String</td> <td>引用可打印的。</td></tr> <tr><td>m</td> <td>String</td> <td>Base64 编码。</td></tr> <tr><td>N</td> <td>Integer</td> <td>把四个字符当作 network 字节顺序的无符号的 long。</td></tr> <tr><td>n</td> <td>Fixnum</td> <td>把两个字符当作 network 字节顺序的无符号的 short。</td></tr> <tr><td>P</td> <td>String</td> <td>把 sizeof(char *) 长度的字符当作指针，并从引用的位置返回 \emph{len} 字符。</td></tr> <tr><td>p</td> <td>String</td> <td>把 sizeof(char *) 长度的字符当作一个空结束字符的指针。</td></tr> <tr><td>Q</td> <td>Integer</td> <td>把八个字符当作无符号的 quad word（64 位）。</td></tr> <tr><td>q</td> <td>Integer</td> <td>把八个字符当作有符号的 quad word（64 位）。</td></tr> <tr><td>S</td> <td>Fixnum</td> <td>把两个（如果使用 _ 则不同）连续字符当作 native 字节顺序的无符号的 short。</td></tr> <tr><td>s</td> <td>Fixnum</td> <td>把两个（如果使用 _ 则不同）连续字符当作 native 字节顺序的有符号的 short。</td></tr> <tr><td>U</td> <td>Integer</td> <td>UTF-8 字符，作为无符号整数。</td></tr> <tr><td>u</td> <td>String</td> <td>UU 编码。</td></tr> <tr><td>V</td> <td>Fixnum</td> <td>把四个字符当作 little-endian 字节顺序的无符号的 long。</td></tr> <tr><td>v</td> <td>Fixnum</td> <td>把两个字符当作 little-endian 字节顺序的无符号的 short。</td></tr> <tr><td>w</td> <td>Integer</td> <td>BER 压缩的整数。</td></tr> <tr><td>X</td> <td></td> <td>向后跳过一个字符。</td></tr> <tr><td>x</td> <td></td> <td>向前跳过一个字符。</td></tr> <tr><td>Z</td> <td>String</td> <td>和 * 一起使用，移除尾随的 null 直到第一个 null。</td></tr> <tr><td>@</td> <td></td> <td>跳过 length 参数给定的偏移量。</td></tr></tbody></table> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token string">&quot;abc \0\0abc \0\0&quot;</span><span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'A6Z6'</span><span class="token punctuation">)</span>   <span class="token comment">#=&gt; [&quot;abc&quot;, &quot;abc &quot;]</span>
<span class="token string">&quot;abc \0\0&quot;</span><span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'a3a3'</span><span class="token punctuation">)</span>           <span class="token comment">#=&gt; [&quot;abc&quot;, &quot; \000\000&quot;]</span>
<span class="token string">&quot;abc \0abc \0&quot;</span><span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'Z*Z*'</span><span class="token punctuation">)</span>       <span class="token comment">#=&gt; [&quot;abc &quot;, &quot;abc &quot;]</span>
<span class="token string">&quot;aa&quot;</span><span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'b8B8'</span><span class="token punctuation">)</span>                 <span class="token comment">#=&gt; [&quot;10000110&quot;, &quot;01100001&quot;]</span>
<span class="token string">&quot;aaa&quot;</span><span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'h2H2c'</span><span class="token punctuation">)</span>               <span class="token comment">#=&gt; [&quot;16&quot;, &quot;61&quot;, 97]</span>
<span class="token string">&quot;\xfe\xff\xfe\xff&quot;</span><span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'sS'</span><span class="token punctuation">)</span>     <span class="token comment">#=&gt; [-2, 65534]</span>
<span class="token string">&quot;now=20is&quot;</span><span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'M*'</span><span class="token punctuation">)</span>             <span class="token comment">#=&gt; [&quot;now is&quot;]</span>
<span class="token string">&quot;whole&quot;</span><span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'xax2aX2aX1aX2a'</span><span class="token punctuation">)</span>    <span class="token comment">#=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</span>
</code></pre></div><ul><li><a href="/school/develop/File类和方法.html">更多文件操作请参考</a>，File 类和方法</li></ul> <h2 id="ruby-数组（array）"><a href="#ruby-数组（array）" class="header-anchor">#</a> Ruby 数组（Array）</h2> <p>Ruby 数组是任何对象的有序整数索引集合。数组中的每个元素都与一个索引相关，并可通过索引进行获取。</p> <p>数组的索引从 0 开始，这与 C 或 Java 中一样。一个负数的索相对于数组的末尾计数的，也就是说，索引为 -1 表示数组的最后一个元素，-2 表示数组中的倒数第二个元素，依此类推。</p> <p>Ruby 数组可存储诸如 String、 Integer、 Fixnum、 Hash、 Symbol 等对象，甚至可以是其他 Array 对象。</p> <p>Ruby 数组不需要指定大小，当向数组添加元素时，Ruby 数组会自动增长。</p> <p>1、创建数组</p> <p>有多种方式创建或初始化数组。一种方式是通过 new 类方法：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>
array1 <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token keyword">new</span>
array2 <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
array3 <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span>
array4 <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">|</span>e<span class="token operator">|</span> e <span class="token operator">=</span> e <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">}</span> <span class="token comment">#块</span>
array5 <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>
array5 <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
array6 <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token punctuation">(</span><span class="token number">0.</span><span class="token number">.9</span><span class="token punctuation">)</span>

puts array2<span class="token punctuation">.</span>size  <span class="token comment"># 返回 20</span>
puts array2<span class="token punctuation">.</span>length <span class="token comment"># 返回 20</span>
puts <span class="token string">&quot;<span class="token interpolation"><span class="token delimiter tag">#{</span>array3<span class="token delimiter tag">}</span></span>&quot;</span> <span class="token comment">#返回 [&quot;name&quot;, &quot;name&quot;, &quot;name&quot;, &quot;name&quot;]</span>

puts <span class="token string">&quot;<span class="token interpolation"><span class="token delimiter tag">#{</span>array4<span class="token delimiter tag">}</span></span>&quot;</span> <span class="token comment">#返回 [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</span>
puts <span class="token string">&quot;<span class="token interpolation"><span class="token delimiter tag">#{</span>array6<span class="token delimiter tag">}</span></span>&quot;</span> <span class="token comment">#返回 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</code></pre></div><p>2、数组内建方法</p> <p>我们需要有一个 Array 对象的实例来调用 Array 方法。下面是创建 Array 对象实例的方式：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">or</span><span class="token punctuation">]</span> <span class="token builtin">Array</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">or</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
</code></pre></div><p>这将返回一个使用给定对象进行填充的新数组。现在，使用创建的对象，我们可以调用任意可用的方法。例如：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>

digits <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token punctuation">(</span><span class="token number">0.</span><span class="token number">.9</span><span class="token punctuation">)</span>

num <span class="token operator">=</span> digits<span class="token punctuation">.</span>at<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>

puts <span class="token string">&quot;<span class="token interpolation"><span class="token delimiter tag">#{</span>num<span class="token delimiter tag">}</span></span>&quot;</span>
</code></pre></div><p>下面是公共的数组方法（假设 array 是一个 Array 对象）：</p> <table><thead><tr><th>序号</th> <th>方法</th> <th>描述</th></tr></thead> <tbody><tr><td>1</td> <td><code>array &amp; other_array</code></td> <td>返回一个新的数组，包含两个数组中共同的元素，没有重复。</td></tr> <tr><td>2</td> <td><code>array * int [or] array * str</code></td> <td>返回一个新的数组，新数组通过连接 self 的 int 副本创建的。带有 String 参数时，相当于 self.join(str)。</td></tr> <tr><td>3</td> <td><code>array + other_array</code></td> <td>返回一个新的数组，新数组通过连接两个数组产生第三个数组创建的。</td></tr> <tr><td>4</td> <td><code>array - other_array</code></td> <td>返回一个新的数组，新数组是从初始数组中移除了在 other_array 中出现的项的副本。</td></tr> <tr><td>5</td> <td><code>str &lt;=&gt; other_str</code></td> <td>把 str 与 other_str 进行比较，返回 -1（小于）、0（等于）或 1（大于）。比较是区分大小写的。</td></tr> <tr><td>6</td> <td><code>array | other_array</code></td> <td>通过把 other_array 加入 array 中，移除重复项，返回一个新的数组。</td></tr> <tr><td>7</td> <td><code>array &lt;&lt; obj</code></td> <td>把给定的对象附加到数组的末尾。该表达式返回数组本身，所以几个附加可以连在一起。</td></tr> <tr><td>8</td> <td><code>array &lt;=&gt; other_array</code></td> <td>如果数组小于、等于或大于 other_array，则返回一个整数（-1、 0 或 +1）。</td></tr> <tr><td>9</td> <td><code>array == other_array</code></td> <td>如果两个数组包含相同的元素个数，且每个元素与另一个数组中相对应的元素相等（根据 Object.==），那么这两个数组相等。</td></tr> <tr><td>10</td> <td><code>array[index] [or] array[start, length] [or]array[range] [or] array.slice(index) [or]array.slice(start, length) [or] array.slice(range)</code></td> <td>返回索引为 index 的元素，或者返回从 start 开始直至 length 个元素的子数组，或者返回 range 指定的子数组。负值索引从数组末尾开始计数（-1 是最后一个元素）。如果 index（或开始索引）超出范围，则返回 nil。</td></tr> <tr><td>11</td> <td><code>array[index] = obj [or]array[start, length] = obj or an_array or nil [or]array[range] = obj or an_array or nil</code></td> <td>设置索引为 index 的元素，或者替换从 start 开始直至 length 个元素的子数组，或者替换 range 指定的子数组。如果索引大于数组的当前容量，那么数组会自动增长。负值索引从数组末尾开始计数。如果 length 为零则插入元素。如果在第二种或第三种形式中使用了 nil，则从 self 删除元素。</td></tr> <tr><td>12</td> <td><code>array.abbrev(pattern = nil)</code></td> <td>为 self 中字符串计算明确的缩写集合。如果传递一个模式或一个字符串，只考虑当字符串匹配模式或者以该字符串开始时的情况。</td></tr> <tr><td>13</td> <td><code>array.assoc(obj)</code></td> <td>搜索一个数组，其元素也是数组，使用 obj.== 把 obj 与每个包含的数组的第一个元素进行比较。如果匹配则返回第一个包含的数组，如果未找到匹配则返回 nil。</td></tr> <tr><td>14</td> <td><code>array.at(index)</code></td> <td>返回索引为 index 的元素。一个负值索引从 self 的末尾开始计数。如果索引超出范围则返回 nil。</td></tr> <tr><td>15</td> <td><code>array.clear</code></td> <td>从数组中移除所有的元素。</td></tr> <tr><td>16</td> <td><code>array.collect { |item| block } [or]array.map { |item| block }</code></td> <td>为 self 中的每个元素调用一次 block。创建一个新的数组，包含 block 返回的值。</td></tr> <tr><td>17</td> <td><code>array.collect! { |item| block } [or]array.map! { |item| block }</code></td> <td>为 self 中的每个元素调用一次 block，把元素替换为 block 返回的值。</td></tr> <tr><td>18</td> <td><code>array.compact</code></td> <td>返回 self 的副本，移除了所有的 nil 元素。</td></tr> <tr><td>19</td> <td><code>array.compact!</code></td> <td>从数组中移除所有的 nil 元素。如果没有变化则返回 nil。</td></tr> <tr><td>20</td> <td><code>array.concat(other_array)</code></td> <td>追加 other_array 中的元素到 self 中。</td></tr> <tr><td>21</td> <td><code>array.delete(obj) [or] array.delete(obj) { block }</code></td> <td>从 self 中删除等于 obj 的项。如果未找到相等项，则返回 nil。如果未找到相等项且给出了可选的代码 block，则返回 block 的结果。</td></tr> <tr><td>22</td> <td><code>array.delete_at(index)</code></td> <td>删除指定的 index 处的元素，并返回该元素。如果 index 超出范围，则返回 nil。</td></tr> <tr><td>23</td> <td><code>array.delete_if { |item| block }</code></td> <td>当 block 为 true 时，删除 self 的每个元素。</td></tr> <tr><td>24</td> <td><code>array.each { |item| block }</code></td> <td>为 self 中的每个元素调用一次 block，传递该元素作为参数。</td></tr> <tr><td>25</td> <td><code>array.each_index { |index| block }</code></td> <td>与 Array#each 相同，但是传递元素的 index，而不是传递元素本身。</td></tr> <tr><td>26</td> <td><code>array.empty?</code></td> <td>如果数组本身没有包含元素，则返回 true。</td></tr> <tr><td>27</td> <td><code>array.eql?(other)</code></td> <td>如果 array 和 other 是相同的对象，或者两个数组带有相同的内容，则返回 true。</td></tr> <tr><td>28</td> <td><code>array.fetch(index) [or] array.fetch(index, default) [or] array.fetch(index) { |index| block }</code></td> <td>尝试返回位置 index 处的元素。如果 index 位于数组外部，则第一种形式会抛出 IndexError 异常，第二种形式会返回 default，第三种形式会返回调用 block 传入 index 的值。负值的 index 从数组末尾开始计数。</td></tr> <tr><td>29</td> <td><code>array.fill(obj) [or]array.fill(obj, start [, length]) [or]array.fill(obj, range) [or]array.fill { |index| block } [or]array.fill(start [, length] ) { |index| block } [or]array.fill(range) { |index| block }</code></td> <td>前面三种形式设置 self 的被选元素为 obj。以 nil 开头相当于零。nil 的长度相当于 self.length。最后三种形式用 block 的值填充数组。block 通过带有被填充的每个元素的绝对索引来传递。</td></tr> <tr><td>30</td> <td><code>array.first [or] array.first(n)</code></td> <td>返回数组的第一个元素或前 n 个元素。如果数组为空，则第一种形式返回 nil，第二种形式返回一个空的数组。</td></tr> <tr><td>31</td> <td><code>array.flatten</code></td> <td>返回一个新的数组，新数组是一个一维的扁平化的数组（递归）。</td></tr> <tr><td>32</td> <td><code>array.flatten!</code></td> <td>把 array 进行扁平化。如果没有变化则返回 nil。（数组不包含子数组。）</td></tr> <tr><td>33</td> <td><code>array.frozen?</code></td> <td>如果 array 被冻结（或排序时暂时冻结），则返回 true。</td></tr> <tr><td>34</td> <td><code>array.hash</code></td> <td>计算数组的哈希代码。两个具有相同内容的数组将具有相同的哈希代码。</td></tr> <tr><td>35</td> <td><code>array.include?(obj)</code></td> <td>如果 self 中包含 obj，则返回 true，否则返回 false。</td></tr> <tr><td>36</td> <td><code>array.index(obj)</code></td> <td>返回 self 中第一个等于 obj 的对象的 index。如果未找到匹配则返回 nil。</td></tr> <tr><td>37</td> <td><code>array.indexes(i1, i2, ... iN) [or] array.indices(i1, i2, ... iN)</code></td> <td>该方法在 Ruby 的最新版本中被废弃，所以请使用 Array#values_at。</td></tr> <tr><td>38</td> <td><code>array.indices(i1, i2, ... iN) [or] array.indexes(i1, i2, ... iN)</code></td> <td>该方法在 Ruby 的最新版本中被废弃，所以请使用 Array#values_at。</td></tr> <tr><td>39</td> <td><code>array.insert(index, obj...)</code></td> <td>在给定的 index 的元素前插入给定的值，index 可以是负值。</td></tr> <tr><td>40</td> <td><code>array.inspect</code></td> <td>创建一个数组的可打印版本。</td></tr> <tr><td>41</td> <td><code>array.join(sep=$,)</code></td> <td>返回一个字符串，通过把数组的每个元素转换为字符串，并使用 sep 分隔进行创建的。</td></tr> <tr><td>42</td> <td><code>array.last [or] array.last(n)</code></td> <td>返回 self 的最后一个元素。如果数组为空，则第一种形式返回 nil。</td></tr> <tr><td>43</td> <td><code>array.length</code></td> <td>返回 self 中元素的个数。可能为零。</td></tr> <tr><td>44</td> <td><code>array.map { |item| block } [or]array.collect { |item| block }</code></td> <td>为 self 的每个元素调用一次 block。创建一个新的数组，包含 block 返回的值。</td></tr> <tr><td>45</td> <td><code>array.map! { |item| block } [or] array.collect! { |item| block }</code></td> <td>为 array 的每个元素调用一次 block，把元素替换为 block 返回的值。</td></tr> <tr><td>46</td> <td><code>array.nitems</code></td> <td>返回 self 中 non-nil 元素的个数。可能为零。</td></tr> <tr><td>47</td> <td><code>array.pack(aTemplateString)</code></td> <td>根据 aTemplateString 中的指令，把数组的内容压缩为二进制序列。指令 A、 a 和 Z 后可以跟一个表示结果字段宽度的数字。剩余的指令也可以带有一个表示要转换的数组元素个数的数字。如果数字是一个星号（*），则所有剩余的数组元素都将被转换。任何指令后都可以跟一个下划线（_），表示指定类型使用底层平台的本地尺寸大小，否则使用独立于平台的一致的尺寸大小。在模板字符串中空格会被忽略。</td></tr> <tr><td>48</td> <td><code>array.pop</code></td> <td>从 array 中移除最后一个元素，并返回该元素。如果 array 为空则返回 nil。</td></tr> <tr><td>49</td> <td><code>array.push(obj, ...)</code></td> <td>把给定的 obj 附加到数组的末尾。该表达式返回数组本身，所以几个附加可以连在一起。</td></tr> <tr><td>50</td> <td><code>array.rassoc(key)</code></td> <td>搜索一个数组，其元素也是数组，使用 == 把 key 与每个包含的数组的第二个元素进行比较。如果匹配则返回第一个包含的数组。</td></tr> <tr><td>51</td> <td><code>array.reject { |item| block }</code></td> <td>返回一个新的数组，包含当 block 不为 true 时的数组项。</td></tr> <tr><td>52</td> <td><code>array.reject! { |item| block }</code></td> <td>当 block 为真时，从 array 删除元素，如果没有变化则返回 nil。相当于 Array#delete_if。</td></tr> <tr><td>53</td> <td><code>array.replace(other_array)</code></td> <td>把 array 的内容替换为 other_array 的内容，必要的时候进行截断或扩充。</td></tr> <tr><td>54</td> <td><code>array.reverse</code></td> <td>返回一个新的数组，包含倒序排列的数组元素。</td></tr> <tr><td>55</td> <td><code>array.reverse!</code></td> <td>把 array 进行逆转。</td></tr> <tr><td>56</td> <td><code>array.reverse_each {|item| block }</code></td> <td>与 Array#each 相同，但是把 array 进行逆转。</td></tr> <tr><td>57</td> <td><code>array.rindex(obj)</code></td> <td>返回 array 中最后一个等于 obj 的对象的索引。如果未找到匹配，则返回 nil。</td></tr> <tr><td>58</td> <td><code>array.select {|item| block }</code></td> <td>调用从数组传入连续元素的 block，返回一个数组，包含 block 返回 true 值时的元素。</td></tr> <tr><td>59</td> <td><code>array.shift</code></td> <td>返回 self 的第一个元素，并移除该元素（把所有的其他元素下移一位）。如果数组为空，则返回 nil。</td></tr> <tr><td>60</td> <td><code>array.size</code></td> <td>返回 array 的长度（元素的个数）。length 的别名。</td></tr> <tr><td>61</td> <td><code>array.slice(index) [or] array.slice(start, length) [or] array.slice(range) [or] array[index] [or] array[start, length] [or] array[range]</code></td> <td>返回索引为 index 的元素，或者返回从 start 开始直至 length 个元素的子数组，或者返回 range 指定的子数组。负值索引从数组末尾开始计数（-1 是最后一个元素）。如果 index（或开始索引）超出范围，则返回 nil。</td></tr> <tr><td>62</td> <td><code>array.slice!(index) [or] array.slice!(start, length) [or] array.slice!(range)</code></td> <td>删除 index（长度是可选的）或 range 指定的元素。返回被删除的对象、子数组，如果 index 超出范围，则返回 nil。</td></tr> <tr><td>63</td> <td><code>array.sort [or] array.sort { | a,b | block }</code></td> <td>返回一个排序的数组。</td></tr> <tr><td>64</td> <td><code>array.sort! [or] array.sort! { | a,b | block }</code></td> <td>把数组进行排序。</td></tr> <tr><td>65</td> <td><code>array.to_a</code></td> <td>返回 self。如果在 Array 的子类上调用，则把接收参数转换为一个 Array 对象。</td></tr> <tr><td>66</td> <td><code>array.to_ary</code></td> <td>返回 self。</td></tr> <tr><td>67</td> <td><code>array.to_s</code></td> <td>返回 self.join。</td></tr> <tr><td>68</td> <td><code>array.transpose</code></td> <td>假设 self 是数组的数组，且置换行和列。</td></tr> <tr><td>69</td> <td><code>array.uniq</code></td> <td>返回一个新的数组，移除了 array 中的重复值。</td></tr> <tr><td>70</td> <td><code>array.uniq!</code></td> <td>从 self 中移除重复元素。如果没有变化（也就是说，未找到重复），则返回 nil。</td></tr> <tr><td>71</td> <td><code>array.unshift(obj, ...)</code></td> <td>把对象前置在数组的前面，其他元素上移一位。</td></tr> <tr><td>72</td> <td><code>array.values_at(selector,...)</code></td> <td>返回一个数组，包含 self 中与给定的 selector（一个或多个）相对应的元素。选择器可以是整数索引或者范围。</td></tr> <tr><td>73</td> <td><code>array.zip(arg, ...) [or] array.zip(arg, ...){ | arr | block }</code></td> <td>把任何参数转换为数组，然后把 array 的元素与每个参数中相对应的元素合并。</td></tr></tbody></table> <p>3、数组 pack 指令</p> <p>下表列出了方法 Array#pack 的压缩指令。</p> <table><thead><tr><th>指令</th> <th>描述</th></tr></thead> <tbody><tr><td>@</td> <td>移动到绝对位置。</td></tr> <tr><td>A</td> <td>ASCII 字符串（填充 space，count 是宽度）。</td></tr> <tr><td>a</td> <td>ASCII 字符串（填充 null，count 是宽度）。</td></tr> <tr><td>B</td> <td>位字符串（降序）</td></tr> <tr><td>b</td> <td>位字符串（升序）。</td></tr> <tr><td>C</td> <td>无符号字符。</td></tr> <tr><td>c</td> <td>字符。</td></tr> <tr><td>D, d</td> <td>双精度浮点数，原生格式。</td></tr> <tr><td>E</td> <td>双精度浮点数，little-endian 字节顺序。</td></tr> <tr><td>e</td> <td>单精度浮点数，little-endian 字节顺序。</td></tr> <tr><td>F, f</td> <td>单精度浮点数，原生格式。</td></tr> <tr><td>G</td> <td>双精度浮点数，network（big-endian）字节顺序。</td></tr> <tr><td>g</td> <td>单精度浮点数，network（big-endian）字节顺序。</td></tr> <tr><td>H</td> <td>十六进制字符串（高位优先）。</td></tr> <tr><td>h</td> <td>十六进制字符串（低位优先）。</td></tr> <tr><td>I</td> <td>无符号整数。</td></tr> <tr><td>i</td> <td>整数。</td></tr> <tr><td>L</td> <td>无符号 long。</td></tr> <tr><td>l</td> <td>Long。</td></tr> <tr><td>M</td> <td>引用可打印的，MIME 编码。</td></tr> <tr><td>m</td> <td>Base64 编码字符串。</td></tr> <tr><td>N</td> <td>Long，network（big-endian）字节顺序。</td></tr> <tr><td>n</td> <td>Short，network（big-endian）字节顺序。</td></tr> <tr><td>P</td> <td>指向一个结构（固定长度的字符串）。</td></tr> <tr><td>p</td> <td>指向一个空结束字符串。</td></tr> <tr><td>Q, q</td> <td>64 位数字。</td></tr> <tr><td>S</td> <td>无符号 short。</td></tr> <tr><td>s</td> <td>Short。</td></tr> <tr><td>U</td> <td>UTF-8。</td></tr> <tr><td>u</td> <td>UU 编码字符串。</td></tr> <tr><td>V</td> <td>Long，little-endian 字节顺序。</td></tr> <tr><td>v</td> <td>Short，little-endian 字节顺序。</td></tr> <tr><td>w</td> <td>BER 压缩的整数 \fnm。</td></tr> <tr><td>X</td> <td>向后跳过一个字节。</td></tr> <tr><td>x</td> <td>Null 字节。</td></tr> <tr><td>Z</td> <td>与 a 相同，除了 null 会被加上 *。</td></tr></tbody></table> <div class="language-ruby extra-class"><pre class="language-ruby"><code>a <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span> <span class="token punctuation">]</span>
n <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">66</span><span class="token punctuation">,</span> <span class="token number">67</span> <span class="token punctuation">]</span>
puts a<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">&quot;A3A3A3&quot;</span><span class="token punctuation">)</span>   <span class="token comment">#=&gt; &quot;a  b  c  &quot;</span>
puts a<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">&quot;a3a3a3&quot;</span><span class="token punctuation">)</span>   <span class="token comment">#=&gt; &quot;a\000\000b\000\000c\000\000&quot;</span>
puts n<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">&quot;ccc&quot;</span><span class="token punctuation">)</span>      <span class="token comment">#=&gt; &quot;ABC&quot;</span>
</code></pre></div><h2 id="ruby-哈希（hash）"><a href="#ruby-哈希（hash）" class="header-anchor">#</a> Ruby 哈希（Hash）</h2> <p>哈希（Hash）是类似 &quot;key&quot; =&gt; &quot;value&quot; 这样的键值对集合。哈希类似于一个数组，只不过它的索引不局限于使用数字。</p> <p>Hash 的索引（或者叫&quot;键&quot;）或值，几乎可以是任何对象。</p> <p>Hash 虽然和数组类似，但却有一个很重要的区别：Hash 的元素没有特定的顺序。 如果顺序很重要的话就要使用数组了。</p> <p>1、创建哈希</p> <p>与数组一样，有各种不同的方式来创建哈希。当您访问带有默认值的哈希中的任意键时，如果键或值不存在，访问哈希将返回默认值：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code>months <span class="token operator">=</span> <span class="token builtin">Hash</span><span class="token punctuation">.</span><span class="token keyword">new</span>
months <span class="token operator">=</span> <span class="token builtin">Hash</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span> <span class="token string">&quot;month&quot;</span> <span class="token punctuation">)</span>
months <span class="token operator">=</span> <span class="token builtin">Hash</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token string">&quot;month&quot;</span>
puts <span class="token string">&quot;<span class="token interpolation"><span class="token delimiter tag">#{</span>months<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token delimiter tag">}</span></span>&quot;</span> <span class="token comment"># -&gt; month</span>
puts <span class="token string">&quot;<span class="token interpolation"><span class="token delimiter tag">#{</span>months<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token delimiter tag">}</span></span>&quot;</span> <span class="token comment"># -&gt; month</span>

<span class="token constant">H</span> <span class="token operator">=</span> <span class="token builtin">Hash</span><span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">]</span>

puts <span class="token string">&quot;<span class="token interpolation"><span class="token delimiter tag">#{</span><span class="token constant">H</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token delimiter tag">}</span></span>&quot;</span> <span class="token comment"># -&gt; 100</span>
puts <span class="token string">&quot;<span class="token interpolation"><span class="token delimiter tag">#{</span><span class="token constant">H</span><span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token delimiter tag">}</span></span>&quot;</span> <span class="token comment"># -&gt; name</span>


<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&quot;jan&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token string">&quot;January&quot;</span>  <span class="token comment"># 该哈希的键为一个数组</span>
</code></pre></div><p>2、哈希内置方法</p> <p>如果需要调用 Hash 方法，需要先实例化一个 Hash 对象。下面是创建 Hash 对象实例的方式：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token builtin">Hash</span><span class="token punctuation">[</span><span class="token punctuation">[</span>key <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token operator">|</span><span class="token punctuation">,</span> value<span class="token punctuation">]</span><span class="token operator">*</span> <span class="token punctuation">]</span> <span class="token keyword">or</span>

<span class="token builtin">Hash</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token punctuation">[</span><span class="token keyword">or</span><span class="token punctuation">]</span> <span class="token builtin">Hash</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">or</span><span class="token punctuation">]</span>

<span class="token builtin">Hash</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token punctuation">{</span> <span class="token operator">|</span>hash<span class="token punctuation">,</span> key<span class="token operator">|</span> block <span class="token punctuation">}</span>
</code></pre></div><p>这将返回一个使用给定对象进行填充的新的哈希。现在，使用创建的对象，我们可以调用任意可用的方法。例如：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>

$<span class="token punctuation">,</span> <span class="token operator">=</span> <span class="token string">&quot;, &quot;</span>
months <span class="token operator">=</span> <span class="token builtin">Hash</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span> <span class="token string">&quot;month&quot;</span> <span class="token punctuation">)</span>

months <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;1&quot;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token string">&quot;January&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;2&quot;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token string">&quot;February&quot;</span><span class="token punctuation">}</span>

keys <span class="token operator">=</span> months<span class="token punctuation">.</span>keys

puts <span class="token string">&quot;<span class="token interpolation"><span class="token delimiter tag">#{</span>keys<span class="token delimiter tag">}</span></span>&quot;</span>  <span class="token comment"># -&gt; [&quot;1&quot;, &quot;2&quot;]</span>
</code></pre></div><p>下面是公共的哈希方法（假设 hash 是一个 Hash 对象）：</p> <table><thead><tr><th>序号</th> <th>方法</th> <th>描述</th></tr></thead> <tbody><tr><td>1</td> <td><code>hash == other_hash</code></td> <td>检查两个哈希是否具有相同的键值对个数，键值对是否相互匹配，来判断两个哈希是否相等。</td></tr> <tr><td>2</td> <td><code>hash.[key]</code></td> <td>使用键，从哈希引用值。如果未找到键，则返回默认值。</td></tr> <tr><td>3</td> <td><code>hash.[key]=value</code></td> <td>把 value 给定的值与 key 给定的键进行关联。</td></tr> <tr><td>4</td> <td><code>hash.clear</code></td> <td>从哈希中移除所有的键值对。</td></tr> <tr><td>5</td> <td><code>hash.default(key = nil)</code></td> <td>返回 hash 的默认值，如果未通过 default= 进行设置，则返回 nil。（如果键在 hash 中不存在，则 [] 返回一个默认值。）</td></tr> <tr><td>6</td> <td><code>hash.default = obj</code></td> <td>为 hash 设置默认值。</td></tr> <tr><td>7</td> <td><code>hash.default_proc</code></td> <td>如果 hash 通过块来创建，则返回块。</td></tr> <tr><td>8</td> <td><code>hash.delete(key) [or] array.delete(key) { |key| block }</code></td> <td>通过 key 从 hash 中删除键值对。如果使用了块 且未找到匹配的键值对，则返回块的结果。把它与 delete_if 进行比较。</td></tr> <tr><td>9</td> <td><code>hash.delete_if { |key,value| block }</code></td> <td>block 为 true 的每个块，从 hash 中删除键值对。</td></tr> <tr><td>10</td> <td><code>hash.each { |key,value| block }</code></td> <td>遍历 hash，为每个 key 调用一次 block，传递 key-value 作为一个二元素数组。</td></tr> <tr><td>11</td> <td><code>hash.each_key { |key| block }</code></td> <td>遍历 hash，为每个 key 调用一次 block，传递 key 作为参数。</td></tr> <tr><td>12</td> <td><code>hash.each_key { |key_value_array| block }</code></td> <td>遍历 hash，为每个 key 调用一次 block，传递 key 和 value 作为参数。</td></tr> <tr><td>13</td> <td><code>hash.each_value { |value| block }</code></td> <td>遍历 hash，为每个 key 调用一次 block，传递 value 作为参数。</td></tr> <tr><td>14</td> <td><code>hash.empty?</code></td> <td>检查 hash 是否为空（不包含键值对），返回 true 或 false。</td></tr> <tr><td>15</td> <td><code>hash.fetch(key [, default] ) [or] hash.fetch(key) { | key | block }</code></td> <td>通过给定的 key 从 hash 返回值。如果未找到 key，且未提供其他参数，则抛出 IndexError 异常；如果给出了 default，则返回 default；如果指定了可选的 block，则返回 block 的结果。</td></tr> <tr><td>16</td> <td><code>hash.has_key?(key) [or] hash.include?(key) [or] hash.key?(key) [or] hash.member?(key)</code></td> <td>检查给定的 key 是否存在于哈希中，返回 true 或 false。</td></tr> <tr><td>17</td> <td><code>hash.has_value?(value)</code></td> <td>检查哈希是否包含给定的 value。</td></tr> <tr><td>18</td> <td><code>hash.index(value)</code></td> <td>为给定的 value 返回哈希中的 key，如果未找到匹配值则返回 nil。</td></tr> <tr><td>19</td> <td><code>hash.indexes(keys)</code></td> <td>返回一个新的数组，由给定的键的值组成。找不到的键将插入默认值。该方法已被废弃，请使用 select。</td></tr> <tr><td>20</td> <td><code>hash.indices(keys)</code></td> <td>返回一个新的数组，由给定的键的值组成。找不到的键将插入默认值。该方法已被废弃，请使用 select。</td></tr> <tr><td>21</td> <td><code>hash.inspect</code></td> <td>返回哈希的打印字符串版本。</td></tr> <tr><td>22</td> <td><code>hash.invert</code></td> <td>创建一个新的 hash，倒置 hash 中的 keys 和 values。也就是说，在新的哈希中，hash 中的键将变成值，值将变成键。</td></tr> <tr><td>23</td> <td><code>hash.keys</code></td> <td>创建一个新的数组，带有 hash 中的键。</td></tr> <tr><td>24</td> <td><code>hash.length</code></td> <td>以整数形式返回 hash 的大小或长度。</td></tr> <tr><td>25</td> <td><code>hash.merge(other_hash) [or] hash.merge(other_hash) { |key, oldval, newval| block }</code></td> <td>返回一个新的哈希，包含 hash 和 other_hash 的内容，重写 hash 中与 other_hash 带有重复键的键值对。</td></tr> <tr><td>26</td> <td><code>hash.merge!(other_hash) [or] hash.merge!(other_hash) { |key, oldval, newval| block }</code></td> <td>与 merge 相同，但实际上 hash 发生了变化。</td></tr> <tr><td>27</td> <td><code>hash.rehash</code></td> <td>基于每个 key 的当前值重新建立 hash。如果插入后值发生了改变，该方法会重新索引 hash。</td></tr> <tr><td>28</td> <td><code>hash.reject { |key, value| block }</code></td> <td>类似 delete_if, 但作用在一个拷贝的哈希上。相等于 hsh.dup.delete_if。</td></tr> <tr><td>29</td> <td><code>hash.reject! { |key, value| block }</code></td> <td>相等于 delete_if, 但是如果没有修改，返回 nil。</td></tr> <tr><td>30</td> <td><code>hash.replace(other_hash)</code></td> <td>把 hash 的内容替换为 other_hash 的内容。</td></tr> <tr><td>31</td> <td><code>hash.select { |key, value| block }</code></td> <td>返回一个新的数组，由 block 返回 true 的 hash 中的键值对组成。</td></tr> <tr><td>32</td> <td><code>hash.shift</code></td> <td>从 hash 中移除一个键值对，并把该键值对作为二元素数组返回。</td></tr> <tr><td>33</td> <td><code>hash.size</code></td> <td>以整数形式返回 hash 的 size 或 length。</td></tr> <tr><td>34</td> <td><code>hash.sort</code></td> <td>把 hash 转换为一个包含键值对数组的二维数组，然后进行排序。</td></tr> <tr><td>35</td> <td><code>hash.store(key, value)</code></td> <td>存储 hash 中的一个键值对。</td></tr> <tr><td>36</td> <td><code>hash.to_a</code></td> <td>从 hash 中创建一个二维数组。每个键值对转换为一个数组，所有这些数组都存储在一个数组中。</td></tr> <tr><td>37</td> <td><code>hash.to_hash</code></td> <td>返回 hash（self）。</td></tr> <tr><td>38</td> <td><code>hash.to_s</code></td> <td>把 hash 转换为一个数组，然后把该数组转换为一个字符串。</td></tr> <tr><td>39</td> <td><code>hash.update(other_hash) [or] hash.update(other_hash) {|key, oldval, newval| block}</code></td> <td>返回一个新的哈希，包含 hash 和 other_hash 的内容，重写 hash 中与 other_hash 带有重复键的键值对。</td></tr> <tr><td>40</td> <td><code>hash.value?(value)</code></td> <td>检查 hash 是否包含给定的 value。</td></tr> <tr><td>41</td> <td><code>hash.values</code></td> <td>返回一个新的数组，包含 hash 的所有值。</td></tr> <tr><td>42</td> <td><code>hash.values_at(obj, ...)</code></td> <td>返回一个新的数组，包含 hash 中与给定的键相关的值。</td></tr></tbody></table> <h2 id="ruby-迭代器"><a href="#ruby-迭代器" class="header-anchor">#</a> Ruby 迭代器</h2> <p>简单来说：迭代(iterate)指的是重复做相同的事，所以迭代器(iterator)就是用来重复多次相同的事。</p> <p>迭代器是集合支持的方法。存储一组数据成员的对象称为集合。在 Ruby 中，数组(Array)和哈希(Hash)可以称之为集合。</p> <p>迭代器返回集合的所有元素。</p> <p>1、each 迭代器</p> <p>each 迭代器总是与一个块关联。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code>collection<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>variable<span class="token operator">|</span>
   code
<span class="token keyword">end</span>
</code></pre></div><div class="language-ruby extra-class"><pre class="language-ruby"><code>sum <span class="token operator">=</span> <span class="token number">0</span>
cutcome <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;block1&quot;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">&quot;book2&quot;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">&quot;book3&quot;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">4000</span><span class="token punctuation">}</span>
cutcome<span class="token punctuation">.</span><span class="token keyword">each</span><span class="token punctuation">{</span><span class="token operator">|</span>pair<span class="token operator">|</span> sum <span class="token operator">+</span><span class="token operator">=</span> pair<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
print <span class="token string">&quot;sum = &quot;</span> <span class="token operator">+</span> sum<span class="token punctuation">.</span>to_s
</code></pre></div><p>2、collect 迭代器</p> <p>collect 方法不是数组间进行复制的正确方式。这里有另一个称为 clone 的方法，用于复制一个数组到另一个数组。</p> <p>当您想要对每个值进行一些操作以便获得新的数组时，您通常使用 collect 方法。例如，下面的代码会生成一个数组，其值是 a 中每个值的 10 倍。</p> <div class="language- extra-class"><pre class="language-text"><code>collection = collection.collect
</code></pre></div><div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>

a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
b <span class="token operator">=</span> a<span class="token punctuation">.</span>collect<span class="token punctuation">{</span><span class="token operator">|</span>x<span class="token operator">|</span> <span class="token number">10</span><span class="token operator">*</span>x<span class="token punctuation">}</span>
puts b

<span class="token comment">#返回如下结果：</span>
<span class="token number">10</span>
<span class="token number">20</span>
<span class="token number">30</span>
<span class="token number">40</span>
<span class="token number">50</span>
</code></pre></div><h2 id="ruby-模块"><a href="#ruby-模块" class="header-anchor">#</a> Ruby 模块</h2> <p>模块（Module）是一种把方法、类和常量组合在一起的方式。模块（Module）为您提供了两大好处:</p> <ul><li><p>模块提供了一个命名空间和避免名字冲突。</p></li> <li><p>模块实现了 mixin 装置。</p></li></ul> <p>模块（Module）定义了一个命名空间，相当于一个沙盒，在里边您的方法和常量不会与其他地方的方法常量冲突。</p> <p>模块类似与类，但有以下不同：</p> <ul><li>模块不能实例化</li> <li>模块没有子类</li> <li>模块只能被另一个模块定义</li></ul> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">module</span> <span class="token constant">MoudleName</span>
   statement1
   statement2
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">end</span>
</code></pre></div><p>模块常量命名与类常量命名类似，以大写字母开头</p> <p>您可以在类方法名称前面放置模块名称和一个点号来调用模块方法，您可以使用模块名称和变量引用符（两个冒号）来引用一个常量。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>

<span class="token comment"># 定义在 trig.rb 文件中的模块</span>

<span class="token keyword">module</span> <span class="token constant">Trig</span>
   <span class="token constant">PI</span> <span class="token operator">=</span> <span class="token number">3.141592654</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token constant">Trig</span><span class="token punctuation">.</span><span class="token function">sin</span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
   <span class="token comment"># ..</span>
   <span class="token keyword">end</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token constant">Trig</span><span class="token punctuation">.</span><span class="token function">cos</span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
   <span class="token comment"># ..</span>
   <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>

<span class="token comment"># 定义在 moral.rb 文件中的模块</span>
<span class="token comment"># 就像类方法，当您在模块中定义一个方法时，您可以指定在模块名称后跟着一个点号，点号后跟着方法名</span>
<span class="token keyword">module</span> <span class="token constant">Moral</span>
   <span class="token constant">VERY_BAD</span> <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token constant">BAD</span> <span class="token operator">=</span> <span class="token number">1</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token constant">Moral</span><span class="token punctuation">.</span><span class="token function">sin</span></span><span class="token punctuation">(</span>badness<span class="token punctuation">)</span>
   <span class="token comment"># ...</span>
   <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>当一个类可以从多个父类继承类的特性时，该类显示为多重继承。</p> <p>Ruby 不直接支持多重继承，但是 Ruby 的模块（Module）有另一个神奇的功能。它几乎消除了多重继承的需要，提供了一种名为 <code>mixin</code> 的装置。将模块 include 到类定义中，模块中的方法就 mix 进了类中。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">module</span> <span class="token constant">A</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">a1</span></span>
   <span class="token keyword">end</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">a2</span></span>
   <span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">module</span> <span class="token constant">B</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">b1</span></span>
   <span class="token keyword">end</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">b2</span></span>
   <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">class</span> <span class="token class-name">Sample</span>
<span class="token keyword">include</span> <span class="token constant">A</span>
<span class="token keyword">include</span> <span class="token constant">B</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">s1</span></span>
   <span class="token keyword">end</span>
<span class="token keyword">end</span>

samp<span class="token operator">=</span><span class="token constant">Sample</span><span class="token punctuation">.</span><span class="token keyword">new</span>
samp<span class="token punctuation">.</span>a1
samp<span class="token punctuation">.</span>a2
samp<span class="token punctuation">.</span>b1
samp<span class="token punctuation">.</span>b2
samp<span class="token punctuation">.</span>s1
<span class="token comment">#可以看到类 Sample 继承了两个模块，您可以说类 Sample 使用了多重继承或 mixin</span>
</code></pre></div><h2 id="ruby-块"><a href="#ruby-块" class="header-anchor">#</a> Ruby 块</h2> <ul><li>块由大量的代码组成。</li> <li>您需要给块取个名称。</li> <li>块中的代码总是包含在大括号 {} 内。</li> <li>块总是从与其具有相同名称的函数调用。这意味着如果您的块名称为 test，那么您要使用函数 test 来调用这个块。</li> <li>您可以使用 <code>yield</code> 语句来调用块。</li></ul> <div class="language-ruby extra-class"><pre class="language-ruby"><code>block_name<span class="token punctuation">{</span>
   statement1
   statement2
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>

<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">test</span></span>
  <span class="token keyword">yield</span>
<span class="token keyword">end</span>
test<span class="token punctuation">{</span> puts <span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">}</span>
</code></pre></div><p>如果方法的最后一个参数前带有 &amp;，那么您可以向该方法传递一个块，且这个块可被赋给最后一个参数。如果 * 和 &amp; 同时出现在参数列表中，&amp; 应放在后面。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>

<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">test</span></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">&amp;</span>block<span class="token punctuation">)</span>
   block<span class="token punctuation">.</span>call
<span class="token keyword">end</span>
test <span class="token punctuation">{</span> puts <span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">}</span>
</code></pre></div><p>每个 Ruby 源文件可以声明当文件被加载时要运行的代码块（BEGIN 块），以及程序完成执行后要运行的代码块（END 块）。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>

<span class="token keyword">BEGIN</span> <span class="token punctuation">{</span>
  <span class="token comment"># BEGIN 代码块</span>
  puts <span class="token string">&quot;BEGIN 代码块&quot;</span>
<span class="token punctuation">}</span>

<span class="token keyword">END</span> <span class="token punctuation">{</span>
  <span class="token comment"># END 代码块</span>
  puts <span class="token string">&quot;END 代码块&quot;</span>
<span class="token punctuation">}</span>
  <span class="token comment"># MAIN 代码块</span>
puts <span class="token string">&quot;MAIN 代码块&quot;</span>

<span class="token comment"># 输出以下结果:</span>
<span class="token comment"># BEGIN 代码块</span>
<span class="token comment"># MAIN 代码块</span>
<span class="token comment"># END 代码块</span>
</code></pre></div><p>一个程序可以包含多个 BEGIN 和 END 块。BEGIN 块按照它们出现的顺序执行。END 块按照它们出现的相反顺序执行。</p> <h2 id="ruby-类和对象"><a href="#ruby-类和对象" class="header-anchor">#</a> Ruby 类和对象</h2> <p>对象是类的实例。Ruby 是一种完美的面向对象编程语言。面向对象编程语言的特性包括：</p> <ul><li>数据封装</li> <li>数据抽象</li> <li>多态性</li> <li>继承</li></ul> <p>在 Ruby 中，类总是以关键字 <code>class</code> 开始，后跟类的名称。类名的首字母应该大写。类 User 如下所示：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">User</span>
<span class="token keyword">end</span>
</code></pre></div><p>在 Ruby 中，您可以使用类的方法 <code>new</code> 创建对象。该方法属于类方法，在 Ruby 库中预定义。您可以给方法 <code>new</code> 传递参数，这些参数可用于初始化类变量。当您想要声明带参数的 <code>new</code> 方法时，您需要在创建类的同时声明方法 <code>initialize</code>。</p> <p><code>initialize</code> 方法是一种特殊类型的方法，将在调用带参数的类的 new 方法时执行。</p> <p>下面的实例创建了 <code>initialize</code> 方法：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">User</span>
   <span class="token variable">@@no_of_users</span><span class="token operator">=</span><span class="token number">0</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> addr<span class="token punctuation">)</span>
      <span class="token variable">@user_id</span><span class="token operator">=</span>id
      <span class="token variable">@user_name</span><span class="token operator">=</span>name
      <span class="token variable">@user_addr</span><span class="token operator">=</span>addr
   <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>在本实例中，您可以声明带有 id、name、addr 作为局部变量的 <code>initialize</code>方法。在这里，<code>def</code>和 <code>end</code> 用于定义 Ruby 方法 <code>initialize</code>。</p> <p>在 <code>initialize</code> 方法中，把这些局部变量的值传给实例变量 @cust_id、@cust_name 和 @cust_addr。在这里，局部变量的值是随着 new 方法进行传递的。</p> <p>现在，您可以创建对象，如下所示：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code>user1<span class="token operator">=</span><span class="token constant">User</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;张三&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;陕西西安&quot;</span><span class="token punctuation">)</span>
user2<span class="token operator">=</span><span class="token constant">User</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;李四&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;浙江杭州&quot;</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="ruby-方法"><a href="#ruby-方法" class="header-anchor">#</a> Ruby 方法</h2> <p>方法名应以小写字母开头。如果您以大写字母作为方法名的开头，Ruby 可能会把它当作常量，从而导致不正确地解析调用。</p> <p>方法应在调用之前定义，否则 Ruby 会产生未定义的方法调用异常。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">method_name</span></span> <span class="token punctuation">[</span><span class="token punctuation">(</span> <span class="token punctuation">[</span>arg <span class="token punctuation">[</span><span class="token operator">=</span> default<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">*</span> arg <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>expr <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
   expr<span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">end</span>
</code></pre></div><p>Ruby 中的每个方法默认都会返回一个值。这个返回的值是最后一个语句的值。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">test</span></span>
   i <span class="token operator">=</span> <span class="token number">1</span>
   j <span class="token operator">=</span> <span class="token number">2</span>
   k <span class="token operator">=</span> <span class="token number">3</span>
<span class="token keyword">end</span>
</code></pre></div><p>在调用这个方法时，将返回最后一个声明的变量 k。
Ruby 允许您声明参数数量可变的方法:</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>
<span class="token comment"># -*- coding: UTF-8 -*-</span>

<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">sample</span></span> <span class="token punctuation">(</span><span class="token operator">*</span>test<span class="token punctuation">)</span>
   puts <span class="token string">&quot;参数个数为 <span class="token interpolation"><span class="token delimiter tag">#{</span>test<span class="token punctuation">.</span>length<span class="token delimiter tag">}</span></span>&quot;</span>
   <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>test<span class="token punctuation">.</span>length
      puts <span class="token string">&quot;参数值为 <span class="token interpolation"><span class="token delimiter tag">#{</span>test<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token delimiter tag">}</span></span>&quot;</span>
   <span class="token keyword">end</span>
<span class="token keyword">end</span>
sample <span class="token string">&quot;Allen&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;55&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;M&quot;</span>
sample <span class="token string">&quot;Master&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;35&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;K&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;User&quot;</span>
</code></pre></div><p>当方法定义在类的外部，方法默认标记为 private。另一方面，如果方法定义在类中的，则默认标记为 public。</p> <p>方法默认的可见性和 private 标记可通过模块（Module）的 public 或 private 改变。</p> <p>当你想要访问类的方法时，您首先需要实例化类。然后，使用对象，您可以访问类的任何成员。</p> <p>Ruby 提供了一种不用实例化即可访问方法的方式。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment"># 方法 return_date 是通过在类名后跟着一个点号，点号后跟着方法名来声明的。</span>
<span class="token keyword">class</span> <span class="token class-name">User</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_name</span></span>
   <span class="token keyword">end</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token constant">User</span><span class="token punctuation">.</span><span class="token function">return_date</span></span>
   <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><h2 id="ruby-异常"><a href="#ruby-异常" class="header-anchor">#</a> Ruby 异常</h2> <p>异常语句 rescue/retry/raise/ensure/else/Catch/Throw</p> <p>1、rescue
Ruby 提供了一个完美的处理异常的机制。我们可以在 begin/end 块中附上可能抛出异常的代码，并使用 <code>rescue</code> 子句告诉 Ruby 完美要处理的异常类型。</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token keyword">begin</span> <span class="token comment">#开始</span>

 <span class="token keyword">raise</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">#抛出异常</span>

<span class="token keyword">rescue</span> <span class="token punctuation">[</span><span class="token constant">ExceptionType</span> <span class="token operator">=</span> <span class="token constant">StandardException</span><span class="token punctuation">]</span> <span class="token comment">#捕获指定类型的异常默认值是 StandardException</span>
 $<span class="token operator">!</span> <span class="token comment">#表示异常信息</span>
 $@ <span class="token comment">#表示异常出现的代码位置</span>
<span class="token keyword">else</span> <span class="token comment">#其余异常</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">ensure</span> <span class="token comment">#不管有没有异常，进入该代码块</span>

<span class="token keyword">end</span> <span class="token comment">#结束</span>
</code></pre></div><p>从 <code>begin</code> 到 <code>rescue</code> 中的一切是受保护的。如果代码块执行期间发生了异常，控制会传到 rescue 和 end 之间的块。</p> <p>对于 <code>begin</code> 块中的每个 <code>rescue</code> 子句，Ruby 把抛出的异常与每个参数进行轮流比较。如果 <code>rescue</code> 子句中命名的异常与当前抛出的异常类型相同，或者是该异常的父类，则匹配成功。</p> <p>如果异常不匹配所有指定的错误类型，我们可以在所有的 <code>rescue</code> 子句后使用一个 <code>else</code> 子句。</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token comment">#!/usr/bin/ruby</span>

<span class="token keyword">begin</span>
   file <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">&quot;/unexistant_file&quot;</span><span class="token punctuation">)</span>
   <span class="token keyword">if</span> file
      puts <span class="token string">&quot;File opened successfully&quot;</span>
   <span class="token keyword">end</span>
<span class="token keyword">rescue</span>
      file <span class="token operator">=</span> <span class="token constant">STDIN</span>
<span class="token keyword">end</span>
print file<span class="token punctuation">,</span> <span class="token string">&quot;==&quot;</span><span class="token punctuation">,</span> <span class="token constant">STDIN</span><span class="token punctuation">,</span> <span class="token string">&quot;\n&quot;</span>
</code></pre></div><p>2、retry</p> <p>您可以使用 <code>rescue</code> 块捕获异常，然后使用 <code>retry</code> 语句从开头开始执行 <code>begin</code> 块。</p> <p>如果 <code>retry</code> 出现在 <code>begin</code> 表达式的 <code>rescue</code> 子句中，则从 begin 主体的开头重新开始。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">begin</span>
   do_something   <span class="token comment"># 抛出的异常</span>
<span class="token keyword">rescue</span>
   <span class="token comment"># 处理错误</span>
   <span class="token keyword">retry</span>          <span class="token comment"># 重新从 begin 开始</span>
<span class="token keyword">end</span>
</code></pre></div><div class="language-rb extra-class"><pre class="language-rb"><code><span class="token comment">#!/usr/bin/ruby</span>

<span class="token keyword">begin</span>
   file <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">&quot;/unexistant_file&quot;</span><span class="token punctuation">)</span>
   <span class="token keyword">if</span> file
      puts <span class="token string">&quot;File opened successfully&quot;</span>
   <span class="token keyword">end</span>
<span class="token keyword">rescue</span>
   fname <span class="token operator">=</span> <span class="token string">&quot;existant_file&quot;</span>
   <span class="token keyword">retry</span>
<span class="token keyword">end</span>

<span class="token comment">=begin
以下是处理流程：

打开时发生异常。
跳到 rescue。fname 被重新赋值。
通过 retry 跳到 begin 的开头。
这次文件成功打开。
继续基本的过程。
=end</span>
</code></pre></div><p>如果 <code>retry</code> 出现在迭代内、块内或者 <code>for</code> 表达式的主体内，则重新开始迭代调用。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1.</span><span class="token number">.5</span>
   <span class="token keyword">retry</span> <span class="token keyword">if</span> some_condition <span class="token comment"># 重新从 i == 1 开始</span>
<span class="token keyword">end</span>
</code></pre></div><p><strong>注</strong>：如果被重新命名的文件不存在，本实例代码会无限尝试。所以异常处理时，谨慎使用 retry。</p> <p>3、raise</p> <p>您可以使用 <code>raise</code> 语句抛出异常。下面的方法在调用时抛出异常。它的第二个消息将被输出。</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token comment"># 第一种形式简单地重新抛出当前异常（如果没有当前异常则抛出一个 RuntimeError）。这用在传入异常之前需要解释异常的异常处理程序中。</span>
<span class="token keyword">raise</span>

<span class="token comment"># 第二种形式创建一个新的 RuntimeError 异常，设置它的消息为给定的字符串。该异常之后抛出到调用堆栈。</span>

<span class="token keyword">raise</span> <span class="token string">&quot;Error Message&quot;</span>

<span class="token comment"># 第三种形式使用第一个参数创建一个异常，然后设置相关的消息为第二个参数。</span>

<span class="token keyword">raise</span> <span class="token constant">ExceptionType</span><span class="token punctuation">,</span> <span class="token string">&quot;Error Message&quot;</span>

<span class="token comment"># 第四种形式与第三种形式类似，您可以添加任何额外的条件语句（比如 unless）来抛出异常。</span>

<span class="token keyword">raise</span> <span class="token constant">ExceptionType</span><span class="token punctuation">,</span> <span class="token string">&quot;Error Message&quot;</span> condition
</code></pre></div><div class="language-rb extra-class"><pre class="language-rb"><code><span class="token comment">#!/usr/bin/ruby</span>

<span class="token keyword">begin</span>
    puts <span class="token string">'I am before the raise.'</span>
    <span class="token keyword">raise</span> <span class="token string">'An error has occurred.'</span>
    puts <span class="token string">'I am after the raise.'</span>
<span class="token keyword">rescue</span>
    puts <span class="token string">'I am rescued.'</span>
<span class="token keyword">end</span>
puts <span class="token string">'I am after the begin block.'</span>

<span class="token comment">=begin 输出结果
I am before the raise.
I am rescued.
I am after the begin block.
=end</span>
</code></pre></div><div class="language-rb extra-class"><pre class="language-rb"><code><span class="token comment">#!/usr/bin/ruby</span>

<span class="token keyword">begin</span>
  <span class="token keyword">raise</span> <span class="token string">'A test exception.'</span>
<span class="token keyword">rescue</span> <span class="token builtin">Exception</span> <span class="token operator">=</span><span class="token operator">&gt;</span> e
  puts e<span class="token punctuation">.</span>message
  puts e<span class="token punctuation">.</span>backtrace<span class="token punctuation">.</span>inspect
<span class="token keyword">end</span>

<span class="token comment">=begin 输出结果
A test exception.
[&quot;main.rb:4&quot;]
=end</span>
</code></pre></div><p>4、ensure</p> <p>有时候，无论是否抛出异常，您需要保证一些处理在代码块结束时完成。例如，您可能在进入时打开了一个文件，当您退出块时，您需要确保关闭文件。</p> <p><code>ensure</code> 子句做的就是这个。<code>ensure</code> 放在最后一个 <code>rescue</code> 子句后，并包含一个块终止时总是执行的代码块。它与块是否正常退出、是否抛出并处理异常、是否因一个未捕获的异常而终止，这些都没关系，<code>ensure</code> 块始终都会运行。</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token keyword">begin</span>
   <span class="token comment">#.. 过程</span>
   <span class="token comment">#.. 抛出异常</span>
<span class="token keyword">rescue</span>
   <span class="token comment">#.. 处理错误</span>
<span class="token keyword">ensure</span>
   <span class="token comment">#.. 最后确保执行</span>
   <span class="token comment">#.. 这总是会执行</span>
<span class="token keyword">end</span>
</code></pre></div><div class="language-rb extra-class"><pre class="language-rb"><code><span class="token keyword">begin</span>
  <span class="token keyword">raise</span> <span class="token string">'A test exception.'</span>
<span class="token keyword">rescue</span> <span class="token builtin">Exception</span> <span class="token operator">=</span><span class="token operator">&gt;</span> e
  puts e<span class="token punctuation">.</span>message
  puts e<span class="token punctuation">.</span>backtrace<span class="token punctuation">.</span>inspect
<span class="token keyword">ensure</span>
  puts <span class="token string">&quot;Ensuring execution&quot;</span>
<span class="token keyword">end</span>

<span class="token comment">=begin 输出结果
A test exception.
[&quot;main.rb:4&quot;]
Ensuring execution
=end</span>
</code></pre></div><p>5、else</p> <p>如果提供了 else 子句，它一般是放置在 rescue 子句之后，任意 ensure 之前。</p> <p>else 子句的主体只有在代码主体没有抛出异常时执行。</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token keyword">begin</span>
   <span class="token comment">#.. 过程</span>
   <span class="token comment">#.. 抛出异常</span>
<span class="token keyword">rescue</span>
   <span class="token comment">#.. 处理错误</span>
<span class="token keyword">else</span>
   <span class="token comment">#.. 如果没有异常则执行</span>
<span class="token keyword">ensure</span>
   <span class="token comment">#.. 最后确保执行</span>
   <span class="token comment">#.. 这总是会执行</span>
<span class="token keyword">end</span>
</code></pre></div><div class="language-rb extra-class"><pre class="language-rb"><code><span class="token keyword">begin</span>
 <span class="token comment"># 抛出 'A test exception.'</span>
 puts <span class="token string">&quot;I'm not raising exception&quot;</span>
<span class="token keyword">rescue</span> <span class="token builtin">Exception</span> <span class="token operator">=</span><span class="token operator">&gt;</span> e
  puts e<span class="token punctuation">.</span>message
  puts e<span class="token punctuation">.</span>backtrace<span class="token punctuation">.</span>inspect
<span class="token keyword">else</span>
   puts <span class="token string">&quot;Congratulations-- no errors!&quot;</span>
<span class="token keyword">ensure</span>
  puts <span class="token string">&quot;Ensuring execution&quot;</span>
<span class="token keyword">end</span>

<span class="token comment">=begin
以上实例运行输出结果为：

I'm not raising exception
Congratulations-- no errors!
Ensuring execution
=end</span>
</code></pre></div><p>6、Catch 和 Throw</p> <p>raise 和 rescue 的异常机制能在发生错误时放弃执行，有时候需要在正常处理时跳出一些深层嵌套的结构。此时 catch 和 throw 就派上用场了。</p> <p>catch 定义了一个使用给定的名称（可以是 Symbol 或 String）作为标签的块。块会正常执行直到遇到一个 throw。</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token keyword">throw</span> <span class="token symbol">:lablename</span>
<span class="token comment">#.. 这不会被执行</span>
catch <span class="token symbol">:lablename</span> <span class="token keyword">do</span>
<span class="token comment">#.. 在遇到一个 throw 后匹配将被执行的 catch</span>
<span class="token keyword">end</span>

或

<span class="token keyword">throw</span> <span class="token symbol">:lablename</span> condition
<span class="token comment">#.. 这不会被执行</span>
catch <span class="token symbol">:lablename</span> <span class="token keyword">do</span>
<span class="token comment">#.. 在遇到一个 throw 后匹配将被执行的 catch</span>
<span class="token keyword">end</span>
</code></pre></div><p>下面的实例中，如果用户键入 '!' 回应任何提示，使用一个 throw 终止与用户的交互。</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">promptAndGet</span></span><span class="token punctuation">(</span>prompt<span class="token punctuation">)</span>
   print prompt
   res <span class="token operator">=</span> readline<span class="token punctuation">.</span>chomp
   <span class="token keyword">throw</span> <span class="token symbol">:quitRequested</span> <span class="token keyword">if</span> res <span class="token operator">==</span> <span class="token string">&quot;!&quot;</span>
   <span class="token keyword">return</span> res
<span class="token keyword">end</span>

catch <span class="token symbol">:quitRequested</span> <span class="token keyword">do</span>
   name <span class="token operator">=</span> promptAndGet<span class="token punctuation">(</span><span class="token string">&quot;Name: &quot;</span><span class="token punctuation">)</span>
   age <span class="token operator">=</span> promptAndGet<span class="token punctuation">(</span><span class="token string">&quot;Age: &quot;</span><span class="token punctuation">)</span>
   sex <span class="token operator">=</span> promptAndGet<span class="token punctuation">(</span><span class="token string">&quot;Sex: &quot;</span><span class="token punctuation">)</span>
   <span class="token comment"># ..</span>
   <span class="token comment"># 处理信息</span>
<span class="token keyword">end</span>
promptAndGet<span class="token punctuation">(</span><span class="token string">&quot;Name:&quot;</span><span class="token punctuation">)</span>

<span class="token comment">=begin
上面的程序需要人工交互，您可以在您的计算机上进行尝试。以上实例运行输出结果为：

Name: Ruby on Rails
Age: 3
Sex: !
Name:Just Ruby
=end</span>
</code></pre></div><p>7、类 Exception</p> <p>Ruby 的标准类和模块抛出异常。所有的异常类组成一个层次，包括顶部的 Exception 类在内。下一层是七种不同的类型：</p> <table><thead><tr><th>异常类型</th> <th>描述</th></tr></thead> <tbody><tr><td>Interrupt</td> <td></td></tr> <tr><td>NoMemoryError</td> <td></td></tr> <tr><td>SignalException</td> <td></td></tr> <tr><td>ScriptError</td> <td></td></tr> <tr><td>StandardError</td> <td></td></tr> <tr><td>SystemExit</td> <td></td></tr></tbody></table> <p>Fatal 是该层中另一种异常，但是 Ruby 解释器只在内部使用它。</p> <p>ScriptError 和 StandardError 都有一些子类，但是在这里我们不需要了解这些细节。最重要的事情是创建我们自己的异常类，它们必须是类 Exception 或其子代的子类。</p> <p>让我们看一个实例：</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token keyword">class</span> <span class="token class-name">FileSaveError</span> <span class="token operator">&lt;</span> <span class="token constant">StandardError</span>
   attr_reader <span class="token symbol">:reason</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>
      <span class="token variable">@reason</span> <span class="token operator">=</span> reason
   <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>现在，看下面的实例，将用到上面的异常：</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token builtin">File</span><span class="token punctuation">.</span>open<span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token string">&quot;w&quot;</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token operator">|</span>file<span class="token operator">|</span>
    <span class="token keyword">begin</span>
        <span class="token comment"># 写出数据 ...</span>
    <span class="token keyword">rescue</span>
        <span class="token comment"># 发生错误</span>
        <span class="token keyword">raise</span> <span class="token constant">FileSaveError</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>$<span class="token operator">!</span><span class="token punctuation">)</span>
    <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div><p>在这里，最重要的一行是 raise FileSaveError.new($!)。我们调用 raise 来示意异常已经发生，把它传给 FileSaveError 的一个新的实例，由于特定的异常引起数据写入失败。</p> <h2 id="ruby-正则表达式"><a href="#ruby-正则表达式" class="header-anchor">#</a> Ruby 正则表达式</h2> <p>正则表达式是一种特殊序列的字符，它通过使用有专门语法的模式来匹配或查找字符串集合。</p> <p>正则表达式用事先定义好的一些特定字符、及这些特定字符的组合，组成一个&quot;规则字符串&quot;，这个&quot;规则字符串&quot;用来表达对字符串的一种过滤逻辑。</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token regex">/pattern/</span>
<span class="token operator">/</span>pattern<span class="token operator">/</span>im    <span class="token comment"># 可以指定选项</span>
<span class="token regex">%r!/usr/local!</span> <span class="token comment"># 使用分隔符的正则表达式</span>
</code></pre></div><p>1、正则表达式修饰符</p> <p>正则表达式从字面上看可能包含一个可选的修饰符，用于控制各方面的匹配。修饰符在第二个斜杠字符后指定，如上面实例所示。下标列出了 可能的修饰符：</p> <table><thead><tr><th>修饰符</th> <th>描述</th></tr></thead> <tbody><tr><td>i</td> <td>当匹配文本时忽略大小写。</td></tr> <tr><td>o</td> <td>只执行一次 #{} 插值，正则表达式在第一次时就进行判断。</td></tr> <tr><td>x</td> <td>忽略空格，允许在整个表达式中放入空白符和注释。</td></tr> <tr><td>m</td> <td>匹配多行，把换行字符识别为正常字符。</td></tr> <tr><td>u,e,s,n</td> <td>把正则表达式解释为 Unicode（UTF-8）、EUC、SJIS 或 ASCII。如果没有指定修饰符，则认为正则表达式使用的是源编码。</td></tr></tbody></table> <p>就像字符串通过 %Q 进行分隔一样，Ruby 允许您以 %r 作为正则表达式的开头，后面跟着任意分隔符。这在描述包含大量您不想转义的斜杠字符时非常有用。</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token comment"># 下面匹配单个斜杠字符，不转义</span>
<span class="token regex">%r|/|</span>

<span class="token comment"># Flag 字符可通过下面的语法进行匹配</span>
<span class="token regex">%r[&lt;/(.*)&gt;]i</span>
</code></pre></div><p>2、正则表达式模式</p> <p>除了控制字符，(+ ? . * ^ $ ( ) [ ] { } | <code>\</code>)，其他所有字符都匹配本身。您可以通过在控制字符前放置一个反斜杠来对控制字符进行转义。</p> <p>下表列出了 Ruby 中可用的正则表达式语法。</p> <table><thead><tr><th>模式</th> <th>描述</th></tr></thead> <tbody><tr><td>^</td> <td>匹配行的开头。</td></tr> <tr><td>$</td> <td>匹配行的结尾。</td></tr> <tr><td>.</td> <td>匹配除了换行符以外的任意单字符。使用 m 选项时，它也可以匹配换行符。</td></tr> <tr><td>[...]</td> <td>匹配在方括号中的任意单字符。</td></tr> <tr><td>[^...]</td> <td>匹配不在方括号中的任意单字符。</td></tr> <tr><td>re*</td> <td>匹配前面的子表达式零次或多次。</td></tr> <tr><td>re+</td> <td>匹配前面的子表达式一次或多次。</td></tr> <tr><td>re?</td> <td>匹配前面的子表达式零次或一次。</td></tr> <tr><td>re{ n}</td> <td>匹配前面的子表达式 n 次。</td></tr> <tr><td>re{ n,}</td> <td>匹配前面的子表达式 n 次或 n 次以上。</td></tr> <tr><td>re{ n, m}</td> <td>匹配前面的子表达式至少 n 次至多 m 次。</td></tr> <tr><td>a<code>|</code> b</td> <td>匹配 a 或 b。</td></tr> <tr><td>(re)</td> <td>对正则表达式进行分组，并记住匹配文本。</td></tr> <tr><td>(?imx)</td> <td>暂时打开正则表达式内的 i、 m 或 x 选项。如果在圆括号中，则只影响圆括号内的部分。</td></tr> <tr><td>(?-imx)</td> <td>暂时关闭正则表达式内的 i、 m 或 x 选项。如果在圆括号中，则只影响圆括号内的部分。</td></tr> <tr><td>(?: re)</td> <td>对正则表达式进行分组，但不记住匹配文本。</td></tr> <tr><td>(?imx: re)</td> <td>暂时打开圆括号内的 i、 m 或 x 选项。</td></tr> <tr><td>(?-imx: re)</td> <td>暂时关闭圆括号内的 i、 m 或 x 选项。</td></tr> <tr><td>(?#...)</td> <td>注释。</td></tr> <tr><td>(?= re)</td> <td>使用模式指定位置。没有范围。</td></tr> <tr><td>(?! re)</td> <td>使用模式的否定指定位置。没有范围。</td></tr> <tr><td>(?&gt; re)</td> <td>匹配无回溯的独立模式。</td></tr> <tr><td>\w</td> <td>匹配单词字符。</td></tr> <tr><td>\W</td> <td>匹配非单词字符。</td></tr> <tr><td>\s</td> <td>匹配空白字符。等价于 [\t\n\r\f]。</td></tr> <tr><td>\S</td> <td>匹配非空白字符。</td></tr> <tr><td>\d</td> <td>匹配数字。等价于 [0-9]。</td></tr> <tr><td>\D</td> <td>匹配非数字。</td></tr> <tr><td>\A</td> <td>匹配字符串的开头。</td></tr> <tr><td>\Z</td> <td>匹配字符串的结尾。如果存在换行符，则只匹配到换行符之前。</td></tr> <tr><td>\z</td> <td>匹配字符串的结尾。</td></tr> <tr><td>\G</td> <td>匹配最后一个匹配完成的点。</td></tr> <tr><td>\b</td> <td>当在括号外时匹配单词边界，当在括号内时匹配退格键（0x08）。</td></tr> <tr><td>\B</td> <td>匹配非单词边界。</td></tr> <tr><td>\n, \t, etc.</td> <td>匹配换行符、回车符、制表符，等等。</td></tr> <tr><td>\1...\9</td> <td>匹配第 n 个分组子表达式。</td></tr> <tr><td>\10</td> <td>如果已匹配过，则匹配第 n 个分组子表达式。否则指向字符编码的八进制表示。</td></tr></tbody></table> <p>3、正则表达式实例</p> <p><strong>字符</strong></p> <table><thead><tr><th>实例</th> <th>描述</th></tr></thead> <tbody><tr><td>/ruby/</td> <td>匹配 &quot;ruby&quot;</td></tr> <tr><td>¥</td> <td>匹配 Yen 符号。Ruby 1.9 和 Ruby 1.8 支持多个字符。</td></tr></tbody></table> <p><strong>字符类</strong></p> <table><thead><tr><th>实例</th> <th>描述</th></tr></thead> <tbody><tr><td>/[Rr]uby/</td> <td>匹配 &quot;Ruby&quot; 或 &quot;ruby&quot;</td></tr> <tr><td>/rub[ye]/</td> <td>匹配 &quot;ruby&quot; 或 &quot;rube&quot;</td></tr> <tr><td>/[aeiou]/</td> <td>匹配任何一个小写元音字母</td></tr> <tr><td>/[0-9]/</td> <td>匹配任何一个数字，与 /[0123456789]/ 相同</td></tr> <tr><td>/[a-z]/</td> <td>匹配任何一个小写 ASCII 字母</td></tr> <tr><td>/[A-Z]/</td> <td>匹配任何一个大写 ASCII 字母</td></tr> <tr><td>/[a-zA-Z0-9]/</td> <td>匹配任何一个括号内的字符</td></tr> <tr><td>/[^aeiou]/</td> <td>匹配任何一个非小写元音字母的字符</td></tr> <tr><td>/[^0-9]/</td> <td>匹配任何一个非数字字符</td></tr></tbody></table> <p><strong>特殊字符类</strong></p> <table><thead><tr><th>实例</th> <th>描述</th></tr></thead> <tbody><tr><td>/./</td> <td>匹配除了换行符以外的其他任意字符</td></tr> <tr><td>/./m</td> <td>在多行模式下，也能匹配换行符</td></tr> <tr><td>/\d/</td> <td>匹配一个数字，等同于 /[0-9]/</td></tr> <tr><td>/\D/</td> <td>匹配一个非数字，等同于 /[^0-9]/</td></tr> <tr><td>/\s/</td> <td>匹配一个空白字符，等同于 /[ \t\r\n\f]/</td></tr> <tr><td>/\S/</td> <td>匹配一个非空白字符，等同于 /[^ \t\r\n\f]/</td></tr> <tr><td>/\w/</td> <td>匹配一个单词字符，等同于 /[A-Za-z0-9_]/</td></tr> <tr><td>/\W/</td> <td>匹配一个非单词字符，等同于 /[^a-za-z0-9_]/</td></tr></tbody></table> <p><strong>重复</strong></p> <table><thead><tr><th>实例</th> <th>描述</th></tr></thead> <tbody><tr><td>/ruby?/</td> <td>匹配 &quot;rub&quot; 或 &quot;ruby&quot;。其中，y 是可有可无的。</td></tr> <tr><td>/ruby*/</td> <td>匹配 &quot;rub&quot; 加上 0 个或多个的 y。</td></tr> <tr><td>/ruby+/</td> <td>匹配 &quot;rub&quot; 加上 1 个或多个的 y。</td></tr> <tr><td>/\d{3}/</td> <td>刚好匹配 3 个数字。</td></tr> <tr><td>/\d{3,}/</td> <td>匹配 3 个或多个数字。</td></tr> <tr><td>/\d{3,5}/</td> <td>匹配 3 个、4 个或 5 个数字。</td></tr></tbody></table> <p><strong>非贪婪重复</strong></p> <p>这会匹配最小次数的重复。</p> <table><thead><tr><th>实例</th> <th>描述</th></tr></thead> <tbody><tr><td>/&lt;.*&gt;/</td> <td>贪婪重复：匹配 &quot;<ruby>perl&gt;&quot;</ruby></td></tr> <tr><td>/&lt;.*?&gt;/</td> <td>非贪婪重复：匹配 &quot;<ruby>perl&gt;&quot; 中的 &quot;<ruby>&quot;</ruby></ruby></td></tr></tbody></table> <p><strong>通过圆括号进行分组</strong></p> <table><thead><tr><th>实例</th> <th>描述</th></tr></thead> <tbody><tr><td>/\D\d+/</td> <td>无分组： + 重复 \d</td></tr> <tr><td>/(\D\d)+/</td> <td>分组： + 重复 \D\d 对</td></tr> <tr><td>/([Rr]uby(, )?)+/</td> <td>匹配 &quot;Ruby&quot;、&quot;Ruby, ruby, ruby&quot;，等等</td></tr></tbody></table> <p><strong>反向引用</strong></p> <p>这会再次匹配之前匹配过的分组。</p> <table><thead><tr><th>实例</th> <th>描述</th></tr></thead> <tbody><tr><td><code>/([Rr])uby&amp;\1ails/</code></td> <td>匹配 ruby&amp;rails 或 Ruby&amp;Rails</td></tr> <tr><td><code>/(['&quot;])(?:(?!\1).)\*\1/</code></td> <td>单引号或双引号字符串。\1 匹配第一个分组所匹配的字符，\2 匹配第二个分组所匹配的字符，依此类推。</td></tr></tbody></table> <p><strong>替换</strong></p> <table><thead><tr><th>实例</th> <th>描述</th></tr></thead> <tbody><tr><td><code>/ruby|rube/</code></td> <td>匹配 &quot;ruby&quot; 或 &quot;rube&quot;</td></tr> <tr><td><code>/rub(y|le)/</code></td> <td>匹配 &quot;ruby&quot; 或 &quot;ruble&quot;</td></tr> <tr><td><code>/ruby(!+|\?)/</code></td> <td>&quot;ruby&quot; 后跟一个或多个 ! 或者跟一个 ?</td></tr></tbody></table> <p><strong>锚</strong></p> <p>这需要指定匹配位置。</p> <table><thead><tr><th>实例</th> <th>描述</th></tr></thead> <tbody><tr><td>/^Ruby/</td> <td>匹配以 &quot;Ruby&quot; 开头的字符串或行</td></tr> <tr><td>/Ruby$/</td> <td>匹配以 &quot;Ruby&quot; 结尾的字符串或行</td></tr> <tr><td>/\ARuby/</td> <td>匹配以 &quot;Ruby&quot; 开头的字符串</td></tr> <tr><td>/Ruby\Z/</td> <td>匹配以 &quot;Ruby&quot; 结尾的字符串</td></tr> <tr><td>/\bRuby\b/</td> <td>匹配单词边界的 &quot;Ruby&quot;</td></tr> <tr><td>/\brub\B/</td> <td>\B 是非单词边界：匹配 &quot;rube&quot; 和 &quot;ruby&quot; 中的 &quot;rub&quot;，但不匹配单独的 &quot;rub&quot;</td></tr> <tr><td>/Ruby(?=!)/</td> <td>如果 &quot;Ruby&quot; 后跟着一个感叹号，则匹配 &quot;Ruby&quot;</td></tr> <tr><td>/Ruby(?!!)/</td> <td>如果 &quot;Ruby&quot; 后没有跟着一个感叹号，则匹配 &quot;Ruby&quot;</td></tr></tbody></table> <p><strong>圆括号的特殊语法</strong></p> <table><thead><tr><th>实例</th> <th>描述</th></tr></thead> <tbody><tr><td>/R(?#comment)/</td> <td>匹配 &quot;R&quot;。所有剩余的字符都是注释。</td></tr> <tr><td>/R(?i)uby/</td> <td>当匹配 &quot;uby&quot; 时不区分大小写。</td></tr> <tr><td>/R(?i:uby)/</td> <td>与上面相同。</td></tr> <tr><td>/rub(?:y<code>|</code>le))/</td> <td>只分组，不进行 \1 反向引用</td></tr></tbody></table> <p>4、搜索和替换</p> <p><code>sub</code> 和 <code>gsub</code> 及它们的替代变量 <code>sub!</code> 和 <code>gsub!</code> 是使用正则表达式时重要的字符串方法。</p> <p>所有这些方法都是使用正则表达式模式执行搜索与替换操作。sub 和 sub! 替换模式的第一次出现，<code>gsub</code> 和 <code>gsub!</code> 替换模式的所有出现。</p> <p>sub 和 <code>gsub</code> 返回一个新的字符串，保持原始的字符串不被修改，而 sub! 和 <code>gsub!</code> 则会修改它们调用的字符串。</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token comment">#!/usr/bin/ruby</span>
<span class="token comment"># -*- coding: UTF-8 -*-</span>

phone <span class="token operator">=</span> <span class="token string">&quot;138-3453-1111 #这是一个电话号码&quot;</span>

<span class="token comment"># 删除 Ruby 的注释</span>
phone <span class="token operator">=</span> phone<span class="token punctuation">.</span>sub<span class="token operator">!</span><span class="token punctuation">(</span><span class="token regex">/#.*$/</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>
puts <span class="token string">&quot;电话号码 : <span class="token interpolation"><span class="token delimiter tag">#{</span>phone<span class="token delimiter tag">}</span></span>&quot;</span>

<span class="token comment"># 移除数字以外的其他字符</span>
phone <span class="token operator">=</span> phone<span class="token punctuation">.</span>gsub<span class="token operator">!</span><span class="token punctuation">(</span><span class="token regex">/\D/</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>
puts <span class="token string">&quot;电话号码 : <span class="token interpolation"><span class="token delimiter tag">#{</span>phone<span class="token delimiter tag">}</span></span>&quot;</span>

<span class="token comment">=begin
以上实例运行输出结果为：

电话号码 : 138-3453-1111
电话号码 : 13834531111
=end</span>
</code></pre></div><div class="language-rb extra-class"><pre class="language-rb"><code><span class="token comment">#!/usr/bin/ruby</span>
<span class="token comment"># -*- coding: UTF-8 -*-</span>

text <span class="token operator">=</span> <span class="token string">&quot;rails 是 rails,  Ruby on Rails 非常好的 Ruby 框架&quot;</span>

<span class="token comment"># 把所有的 &quot;rails&quot; 改为 &quot;Rails&quot;</span>
text<span class="token punctuation">.</span>gsub<span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">&quot;rails&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Rails&quot;</span><span class="token punctuation">)</span>

<span class="token comment"># 把所有的单词 &quot;Rails&quot; 都改成首字母大写</span>
text<span class="token punctuation">.</span>gsub<span class="token operator">!</span><span class="token punctuation">(</span><span class="token regex">/\brails\b/</span><span class="token punctuation">,</span> <span class="token string">&quot;Rails&quot;</span><span class="token punctuation">)</span>

puts <span class="token string">&quot;<span class="token interpolation"><span class="token delimiter tag">#{</span>text<span class="token delimiter tag">}</span></span>&quot;</span>

<span class="token comment">=begin
以上实例运行输出结果为：

Rails 是 Rails,  Ruby on Rails 非常好的 Ruby 框架
=end</span>
</code></pre></div><h2 id="ruby-日期-时间（date-time）"><a href="#ruby-日期-时间（date-time）" class="header-anchor">#</a> Ruby 日期 &amp; 时间（Date &amp; Time）</h2> <p>Time 类在 Ruby 中用于表示日期和时间。它是基于操作系统提供的系统日期和时间之上。该类可能无法表示 1970 年之前或者 2038 年之后的日期。</p> <p>1、创建当前的日期和时间</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby -w</span>
<span class="token comment"># -*- coding: UTF-8 -*-</span>

time1 <span class="token operator">=</span> <span class="token builtin">Time</span><span class="token punctuation">.</span><span class="token keyword">new</span>

puts <span class="token string">&quot;当前时间 : &quot;</span> <span class="token operator">+</span> time1<span class="token punctuation">.</span>inspect

<span class="token comment"># Time.now 功能相同</span>
time2 <span class="token operator">=</span> <span class="token builtin">Time</span><span class="token punctuation">.</span>now
puts <span class="token string">&quot;当前时间 : &quot;</span> <span class="token operator">+</span> time2<span class="token punctuation">.</span>inspect
</code></pre></div><p>2、获取 Date &amp; Time 组件</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby -w</span>
<span class="token comment"># -*- coding: UTF-8 -*-</span>

time <span class="token operator">=</span> <span class="token builtin">Time</span><span class="token punctuation">.</span><span class="token keyword">new</span>

<span class="token comment"># Time 的组件</span>
puts <span class="token string">&quot;当前时间 : &quot;</span> <span class="token operator">+</span> time<span class="token punctuation">.</span>inspect
puts time<span class="token punctuation">.</span>year    <span class="token comment"># =&gt; 日期的年份</span>
puts time<span class="token punctuation">.</span>month   <span class="token comment"># =&gt; 日期的月份（1 到 12）</span>
puts time<span class="token punctuation">.</span>day     <span class="token comment"># =&gt; 一个月中的第几天（1 到 31）</span>
puts time<span class="token punctuation">.</span>wday    <span class="token comment"># =&gt; 一周中的星期几（0 是星期日）</span>
puts time<span class="token punctuation">.</span>yday    <span class="token comment"># =&gt; 365：一年中的第几天</span>
puts time<span class="token punctuation">.</span>hour    <span class="token comment"># =&gt; 23：24 小时制</span>
puts time<span class="token punctuation">.</span>min     <span class="token comment"># =&gt; 59</span>
puts time<span class="token punctuation">.</span>sec     <span class="token comment"># =&gt; 59</span>
puts time<span class="token punctuation">.</span>usec    <span class="token comment"># =&gt; 999999：微秒</span>
puts time<span class="token punctuation">.</span>zone    <span class="token comment"># =&gt; &quot;UTC&quot;：时区名称</span>
</code></pre></div><p>3、时区和夏令时</p> <p><code>Time.utc、Time.gm 和 Time.local</code> 这些函数可用于格式化标准格式的日期，如下所示：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment"># July 8, 2020</span>
<span class="token builtin">Time</span><span class="token punctuation">.</span>local<span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>
<span class="token comment"># July 8, 2020, 09:10am，本地时间</span>
<span class="token builtin">Time</span><span class="token punctuation">.</span>local<span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token comment"># July 8, 2020, 09:10 UTC</span>
<span class="token builtin">Time</span><span class="token punctuation">.</span>utc<span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token comment"># July 8, 2020, 09:10:11 GMT （与 UTC 相同）</span>
<span class="token builtin">Time</span><span class="token punctuation">.</span>gm<span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span>
</code></pre></div><p>下面的实例在数组中获取所有的组件,该数组可被传到 Time.utc 或 Time.local 函数来获取日期的不同格式，如下所示：</p> <p><strong>[sec,min,hour,day,month,year,wday,yday,isdst,zone]</strong></p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby -w</span>

time <span class="token operator">=</span> <span class="token builtin">Time</span><span class="token punctuation">.</span><span class="token keyword">new</span>

values <span class="token operator">=</span> time<span class="token punctuation">.</span>to_a
p values <span class="token comment"># -&gt; [39, 25, 15, 17, 9, 2020, 4, 260, false, &quot;CST&quot;]</span>
puts <span class="token builtin">Time</span><span class="token punctuation">.</span>utc<span class="token punctuation">(</span><span class="token operator">*</span>values<span class="token punctuation">)</span> <span class="token comment"># -&gt; 2020-09-17 15:26:09 UTC</span>
</code></pre></div><div class="language-ruby extra-class"><pre class="language-ruby"><code>time <span class="token operator">=</span> <span class="token builtin">Time</span><span class="token punctuation">.</span><span class="token keyword">new</span>

<span class="token comment"># 这里是解释</span>
time<span class="token punctuation">.</span>zone       <span class="token comment"># =&gt; &quot;UTC&quot;：返回时区</span>
time<span class="token punctuation">.</span>utc_offset <span class="token comment"># =&gt; 0：UTC 是相对于 UTC 的 0 秒偏移</span>
time<span class="token punctuation">.</span>zone       <span class="token comment"># =&gt; &quot;PST&quot;（或其他时区）</span>
time<span class="token punctuation">.</span>isdst      <span class="token comment"># =&gt; false：如果 UTC 没有 DST（夏令时）</span>
time<span class="token punctuation">.</span>utc<span class="token operator">?</span>       <span class="token comment"># =&gt; true：如果在 UTC 时区</span>
time<span class="token punctuation">.</span>localtime  <span class="token comment"># 转换为本地时区</span>
time<span class="token punctuation">.</span>gmtime     <span class="token comment"># 转换回 UTC</span>
time<span class="token punctuation">.</span>getlocal   <span class="token comment"># 返回本地区中的一个新的 Time 对象</span>
time<span class="token punctuation">.</span>getutc     <span class="token comment"># 返回 UTC 中的一个新的 Time 对象</span>
</code></pre></div><p>4、格式化时间和日期</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby -w</span>
time <span class="token operator">=</span> <span class="token builtin">Time</span><span class="token punctuation">.</span><span class="token keyword">new</span>

puts time<span class="token punctuation">.</span>to_s <span class="token comment"># -&gt; 2020-09-17 15:26:42 +0800</span>
puts time<span class="token punctuation">.</span>ctime <span class="token comment"># -&gt; Thu Sep 17 15:26:42 2020</span>
puts time<span class="token punctuation">.</span>localtime <span class="token comment"># -&gt; 2020-09-17 15:26:42 +0800</span>
puts time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">&quot;%Y-%m-%d %H:%M:%S&quot;</span><span class="token punctuation">)</span> <span class="token comment"># -&gt; 2020-09-17 15:26:42</span>

time <span class="token operator">=</span> <span class="token builtin">Time</span><span class="token punctuation">.</span>now
puts time<span class="token punctuation">.</span>to_i  <span class="token comment"># 返回从纪元以来的秒数</span>
puts <span class="token builtin">Time</span><span class="token punctuation">.</span>at<span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token comment"># 把秒数转换为 Time 对象</span>
puts time<span class="token punctuation">.</span>to_f <span class="token comment"># 返回从纪元以来的秒数，包含微妙</span>
</code></pre></div><p>5、时间格式化指令</p> <p>下表所列出的指令与方法 Time.strftime 一起使用。</p> <table><thead><tr><th>指令</th> <th>描述</th></tr></thead> <tbody><tr><td>%a</td> <td>星期几名称的缩写（比如 Sun）。</td></tr> <tr><td>%A</td> <td>星期几名称的全称（比如 Sunday）。</td></tr> <tr><td>%b</td> <td>月份名称的缩写（比如 Jan）。</td></tr> <tr><td>%B</td> <td>月份名称的全称（比如 January）。</td></tr> <tr><td>%c</td> <td>优选的本地日期和时间表示法。</td></tr> <tr><td>%d</td> <td>一个月中的第几天（01 到 31）。</td></tr> <tr><td>%H</td> <td>一天中的第几小时，24 小时制（00 到 23）。</td></tr> <tr><td>%I</td> <td>一天中的第几小时，12 小时制（01 到 12）。</td></tr> <tr><td>%j</td> <td>一年中的第几天（001 到 366）。</td></tr> <tr><td>%m</td> <td>一年中的第几月（01 到 12）。</td></tr> <tr><td>%M</td> <td>小时中的第几分钟（00 到 59）。</td></tr> <tr><td>%p</td> <td>子午线指示（AM 或 PM）。</td></tr> <tr><td>%S</td> <td>分钟中的第几秒（00 或 60）。</td></tr> <tr><td>%U</td> <td>当前年中的周数，从第一个星期日（作为第一周的第一天）开始（00 到 53）。</td></tr> <tr><td>%W</td> <td>当前年中的周数，从第一个星期一（作为第一周的第一天）开始（00 到 53）。</td></tr> <tr><td>%w</td> <td>一星期中的第几天（Sunday 是 0，0 到 6）。</td></tr> <tr><td>%x</td> <td>只有日期没有时间的优先表示法。</td></tr> <tr><td>%X</td> <td>只有时间没有日期的优先表示法。</td></tr> <tr><td>%y</td> <td>不带世纪的年份表示（00 到 99）。</td></tr> <tr><td>%Y</td> <td>带有世纪的年份。</td></tr> <tr><td>%Z</td> <td>时区名称。</td></tr> <tr><td>%%</td> <td>% 字符。</td></tr></tbody></table> <p>6、时间算法</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code>now <span class="token operator">=</span> <span class="token builtin">Time</span><span class="token punctuation">.</span>now  <span class="token comment"># 2020-09-17 15:27:08 +0800</span>
past <span class="token operator">=</span> now <span class="token operator">-</span> <span class="token number">10</span> <span class="token comment"># 2020-09-17 15:26:58 +0800</span>
future <span class="token operator">=</span> now <span class="token operator">+</span> <span class="token number">10</span> <span class="token comment"># 2020-09-17 15:27:18 +0800</span>
diff <span class="token operator">=</span> future <span class="token operator">-</span> now <span class="token comment"># 10.0</span>
</code></pre></div><h2 id="ruby-文件操作"><a href="#ruby-文件操作" class="header-anchor">#</a> Ruby 文件操作</h2> <p>1、File.new</p> <p>创建一个 File 对象用于读取、写入或者读写，读写权限取决于 mode 参数。可以使用 File.close 方法来关闭该文件。</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code>aFile <span class="token operator">=</span> <span class="token builtin">File</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">&quot;filename&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;mode&quot;</span><span class="token punctuation">)</span>
   <span class="token comment"># ... 处理文件</span>
aFile<span class="token punctuation">.</span>close
</code></pre></div><p>2、File.open</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token builtin">File</span><span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">&quot;filename&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;mode&quot;</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token operator">|</span>aFile<span class="token operator">|</span>
   <span class="token comment"># ... process the file</span>
<span class="token keyword">end</span>
</code></pre></div><p><code>File.open</code> 和 <code>File.new</code> 方法之间异同点：</p> <ul><li>相同点：都是创建一个新的 <code>file</code> 对象，并把该 <code>file</code> 对象赋值给文件。</li> <li>不同点：是 <code>File.open</code> 方法可与块关联，而 <code>File.new</code> 方法不能。</li></ul> <p>下表列出了<code>File.open</code> 和 <code>File.new</code> 方法中可使用的模式：</p> <table><thead><tr><th>模式</th> <th>描述</th></tr></thead> <tbody><tr><td>r</td> <td>只读模式。文件指针被放置在文件的开头。这是默认模式。</td></tr> <tr><td>r+</td> <td>读写模式。文件指针被放置在文件的开头。</td></tr> <tr><td>w</td> <td>只写模式。如果文件存在，则重写文件。如果文件不存在，则创建一个新文件用于写入。</td></tr> <tr><td>w+</td> <td>读写模式。如果文件存在，则重写已存在的文件。如果文件不存在，则创建一个新文件用于读写。</td></tr> <tr><td>a</td> <td>只写模式。如果文件存在，则文件指针被放置在文件的末尾。也就是说，文件是追加模式。如果文件不存在，则创建一个新文件用于写入。</td></tr> <tr><td>a+</td> <td>读写模式。如果文件存在，则文件指针被放置在文件的末尾。也就是说，文件是追加模式。如果文件不存在，则创建一个新文件用于读写。</td></tr></tbody></table> <p>3、File.chmod</p> <p>下表列出了 chmod 方法中可使用的不同的掩码：</p> <table><thead><tr><th>掩码</th> <th>描述</th></tr></thead> <tbody><tr><td>0700</td> <td>rwx 掩码，针对所有者</td></tr> <tr><td>0400</td> <td>r ，针对所有者</td></tr> <tr><td>0200</td> <td>w ，针对所有者</td></tr> <tr><td>0100</td> <td>x ，针对所有者</td></tr> <tr><td>0070</td> <td>rwx 掩码，针对所属组</td></tr> <tr><td>0040</td> <td>r ，针对所属组</td></tr> <tr><td>0020</td> <td>w ，针对所属组</td></tr> <tr><td>0010</td> <td>x ，针对所属组</td></tr> <tr><td>0007</td> <td>rwx 掩码，针对其他人</td></tr> <tr><td>0004</td> <td>r ，针对其他人</td></tr> <tr><td>0002</td> <td>w ，针对其他人</td></tr> <tr><td>0001</td> <td>x ，针对其他人</td></tr> <tr><td>4000</td> <td>执行时设置用户 ID</td></tr> <tr><td>2000</td> <td>执行时设置所属组 ID</td></tr> <tr><td>1000</td> <td>保存交换文本，甚至在使用后也会保存</td></tr></tbody></table> <p>4、文件常用操作方法总结：</p> <table><thead><tr><th>方法</th> <th>说明</th></tr></thead> <tbody><tr><td>sysread</td> <td></td></tr> <tr><td>syswrite</td> <td></td></tr> <tr><td>each_byte</td> <td></td></tr> <tr><td>IO.readlines</td> <td></td></tr> <tr><td>IO.foreach</td> <td></td></tr></tbody></table> <p>文件常用操作实例：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment">#!/usr/bin/ruby</span>


aFile <span class="token operator">=</span> <span class="token builtin">File</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">&quot;input.txt&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;r&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> aFile
   content <span class="token operator">=</span> aFile<span class="token punctuation">.</span>sysread<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
   puts content
<span class="token keyword">else</span>
   puts <span class="token string">&quot;Unable to open file!&quot;</span>
<span class="token keyword">end</span>

aFile <span class="token operator">=</span> <span class="token builtin">File</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">&quot;input.txt&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;r+&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> aFile
   aFile<span class="token punctuation">.</span>syswrite<span class="token punctuation">(</span><span class="token string">&quot;ABCDEF&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
   puts <span class="token string">&quot;Unable to open file!&quot;</span>
<span class="token keyword">end</span>

aFile <span class="token operator">=</span> <span class="token builtin">File</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">&quot;input.txt&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;r+&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> aFile
   aFile<span class="token punctuation">.</span>syswrite<span class="token punctuation">(</span><span class="token string">&quot;ABCDEF&quot;</span><span class="token punctuation">)</span>
   aFile<span class="token punctuation">.</span>rewind
   aFile<span class="token punctuation">.</span>each_byte <span class="token punctuation">{</span><span class="token operator">|</span>ch<span class="token operator">|</span> putc ch<span class="token punctuation">;</span> putc <span class="token operator">?</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">else</span>
   puts <span class="token string">&quot;Unable to open file!&quot;</span>
<span class="token keyword">end</span>

arr <span class="token operator">=</span> <span class="token builtin">IO</span><span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token string">&quot;input.txt&quot;</span><span class="token punctuation">)</span>
puts arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
puts arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>

<span class="token builtin">IO</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span><span class="token string">&quot;input.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">|</span>block<span class="token operator">|</span> puts block<span class="token punctuation">}</span>

<span class="token comment"># 重命名文件 test1.txt 为 test2.txt</span>
<span class="token builtin">File</span><span class="token punctuation">.</span>rename<span class="token punctuation">(</span> <span class="token string">&quot;test1.txt&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;test2.txt&quot;</span> <span class="token punctuation">)</span>
<span class="token comment"># 删除文件 test2.txt</span>
<span class="token builtin">File</span><span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token string">&quot;text2.txt&quot;</span><span class="token punctuation">)</span>
file <span class="token operator">=</span> <span class="token builtin">File</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span> <span class="token string">&quot;test.txt&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;w&quot;</span> <span class="token punctuation">)</span>
file<span class="token punctuation">.</span>chmod<span class="token punctuation">(</span> <span class="token number">0755</span> <span class="token punctuation">)</span>
</code></pre></div><h2 id="ruby-目录操作"><a href="#ruby-目录操作" class="header-anchor">#</a> Ruby 目录操作</h2> <p>1、目录操作常见有以下几种方法：</p> <ul><li>创建目录</li> <li>删除目录</li> <li>浏览目录</li></ul> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token comment"># **********创建目录**********</span>
<span class="token comment"># 掩码 755 设置所有者（owner）、所属组（group）、每个人（world [anyone]）的权限为 rwxrxrx，其中 r = read 读取，w = write 写入，x = execute 执行。</span>
<span class="token builtin">Dir</span><span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span><span class="token string">&quot;mynewdir&quot;</span><span class="token punctuation">)</span>
<span class="token builtin">Dir</span><span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span> <span class="token string">&quot;mynewdir&quot;</span><span class="token punctuation">,</span> <span class="token number">755</span> <span class="token punctuation">)</span>


<span class="token comment"># **********删除目录**********</span>
<span class="token comment"># Dir.delete 可用于删除目录。Dir.unlink 和 Dir.rmdir 执行同样的功能</span>
<span class="token builtin">Dir</span><span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token string">&quot;testdir&quot;</span><span class="token punctuation">)</span>


<span class="token comment"># **********浏览目录**********</span>
<span class="token comment"># 改变当前目录为 /usr/bin</span>
<span class="token builtin">Dir</span><span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">&quot;/usr/bin&quot;</span><span class="token punctuation">)</span>
<span class="token comment"># 查看当前目录</span>
<span class="token builtin">Dir</span><span class="token punctuation">.</span>pwd
<span class="token comment"># 获取指定目录内的文件和目录列表</span>
<span class="token builtin">Dir</span><span class="token punctuation">.</span>entries<span class="token punctuation">(</span><span class="token string">&quot;/usr/bin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>

<span class="token comment"># Dir.entries 返回一个数组，包含指定目录内的所有项。Dir.foreach 提供了相同的功能</span>
<span class="token builtin">Dir</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span><span class="token string">&quot;/usr/bin&quot;</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token operator">|</span>entry<span class="token operator">|</span>
   puts entry
<span class="token keyword">end</span>
</code></pre></div><p>2、创建临时文件 &amp; 目录</p> <p>临时文件是那些在程序执行过程中被简单地创建，但不会永久性存储的信息。</p> <p>Dir.tmpdir 提供了当前系统上临时目录的路径，但是该方法默认情况下是不可用的。为了让 Dir.tmpdir 可用，使用必需的 'tmpdir' 是必要的。</p> <p>您可以把 Dir.tmpdir 和 File.join 一起使用，来创建一个独立于平台的临时文件：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">require</span> <span class="token string">'tmpdir'</span>
tempfilename <span class="token operator">=</span> <span class="token builtin">File</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token builtin">Dir</span><span class="token punctuation">.</span>tmpdir<span class="token punctuation">,</span> <span class="token string">&quot;tingtong&quot;</span><span class="token punctuation">)</span>
tempfile <span class="token operator">=</span> <span class="token builtin">File</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>tempfilename<span class="token punctuation">,</span> <span class="token string">&quot;w&quot;</span><span class="token punctuation">)</span>
tempfile<span class="token punctuation">.</span>puts <span class="token string">&quot;This is a temporary file&quot;</span>
tempfile<span class="token punctuation">.</span>close
<span class="token builtin">File</span><span class="token punctuation">.</span>delete<span class="token punctuation">(</span>tempfilename<span class="token punctuation">)</span>
</code></pre></div><p>这段代码创建了一个临时文件，并向其中写入数据，然后删除文件。Ruby 的标准库也包含了一个名为 Tempfile 的库，该库可用于创建临时文件：</p> <div class="language-ruby extra-class"><pre class="language-ruby"><code><span class="token keyword">require</span> <span class="token string">'tempfile'</span>
f <span class="token operator">=</span> <span class="token constant">Tempfile</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token string">'tingtong'</span><span class="token punctuation">)</span>
f<span class="token punctuation">.</span>puts <span class="token string">&quot;Hello&quot;</span>
puts f<span class="token punctuation">.</span>path
f<span class="token punctuation">.</span>close
</code></pre></div><ul><li><a href="/school/develop/Dir类和方法.html">更多目录操作请参考</a>，Dir 类和方法</li></ul> <h2 id="ruby-file-类和方法"><a href="#ruby-file-类和方法" class="header-anchor">#</a> Ruby File 类和方法</h2> <p>1、类方法</p> <table><thead><tr><th>序号</th> <th>方法</th> <th>描述</th></tr></thead> <tbody><tr><td>1</td> <td><code>File::atime( path)</code></td> <td>返回 path 的最后访问时间。</td></tr> <tr><td>2</td> <td><code>File::basename( path[, suffix])</code></td> <td>返回 path 末尾的文件名。如果指定了 suffix，则它会从文件名末尾被删除。例如：File.basename(&quot;/home/users/bin/ruby.exe&quot;) #=&gt; &quot;ruby.exe&quot;</td></tr> <tr><td>3</td> <td><code>File::blockdev?( path)</code></td> <td>如果 path 是一个块设备，则返回 true。</td></tr> <tr><td>4</td> <td><code>File::chardev?( path)</code></td> <td>如果 path 是一个字符设备，则返回 true。</td></tr> <tr><td>5</td> <td><code>File::chmod( mode, path...)</code></td> <td>改变指定文件的权限模式。</td></tr> <tr><td>6</td> <td><code>File::chown( owner, group, path...)</code></td> <td>改变指定文件的所有者和所属组。</td></tr> <tr><td>7</td> <td><code>File::ctime( path)</code></td> <td>返回 path 的最后一个 inode 更改时间。</td></tr> <tr><td>8</td> <td><code>File::delete( path...) File::unlink( path...)</code></td> <td>删除指定的文件。</td></tr> <tr><td>9</td> <td><code>File::directory?( path)</code></td> <td>如果 path 是一个目录，则返回 true。</td></tr> <tr><td>10</td> <td><code>File::dirname( path)</code></td> <td>返回 path 的目录部分，不包括最后的文件名。</td></tr> <tr><td>11</td> <td><code>File::executable?( path)</code></td> <td>如果 path 是可执行的，则返回 true。</td></tr> <tr><td>12</td> <td><code>File::executable_real?( path)</code></td> <td>如果 path 通过真正的用户权限是可执行的，则返回 true。</td></tr> <tr><td>13</td> <td><code>File::exist?( path)</code></td> <td>如果 path 存在，则返回 true。</td></tr> <tr><td>1</td> <td><code>File::expand_path( path[, dir])</code></td> <td>返回 path 的绝对路径，扩展 ~ 为进程所有者的主目录，~user 为用户的主目录。相对路径是相对于 dir 指定的目录，如果 dir 被省略则相对于当前工作目录。</td></tr> <tr><td>14</td> <td><code>File::file?( path)</code></td> <td>如果 path 是一个普通文件，则返回 true。</td></tr> <tr><td>15</td> <td><code>File::ftype( path)</code></td> <td>返回下列其中一个字符串,表示文件类型：file - 普通文件 directory - 目录 characterSpecial - 字符特殊文件 blockSpecial - 块特殊文件 fifo - 命名管道（FIFO） link - 符号链接 socket - Socket unknown - 未知的文件类型</td></tr> <tr><td>16</td> <td><code>File::grpowned?( path)</code></td> <td>如果 path 由用户的所属组所有，则返回 true。</td></tr> <tr><td>17</td> <td><code>File::join( item...)</code></td> <td>返回一个字符串，由指定的项连接在一起，并使用 File::Separator 进行分隔。例如：File::join(&quot;&quot;, &quot;home&quot;, &quot;usrs&quot;, &quot;bin&quot;) # =&gt; &quot;/home/usrs/bin&quot;</td></tr> <tr><td>18</td> <td><code>File::link( old, new)</code></td> <td>创建一个到文件 old 的硬链接。</td></tr> <tr><td>19</td> <td><code>File::lstat( path)</code></td> <td>与 stat 相同，但是它返回自身符号链接上的信息，而不是所指向的文件。</td></tr> <tr><td>20</td> <td><code>File::mtime( path)</code></td> <td>返回 path 的最后一次修改时间。</td></tr> <tr><td>21</td> <td><code>File::new( path[, mode=&quot;r&quot;]) File::open( path[, mode=&quot;r&quot;]) File::open( path[, mode=&quot;r&quot;]) {|f| ...}</code></td> <td>打开文件。如果指定了块，则通过传递新文件作为参数来执行块。当块退出时，文件会自动关闭。这些方法有别于 Kernel.open，即使 path 是以</td></tr> <tr><td>22</td> <td><code>File::owned?( path)</code></td> <td>如果 path 由有效的用户所有，则返回 true。</td></tr> <tr><td>23</td> <td><code>File::pipe?( path)</code></td> <td>如果 path 是一个管道，则返回 true。</td></tr> <tr><td>24</td> <td><code>File::readable?( path)</code></td> <td>如果 path 是可读的，则返回 true。</td></tr> <tr><td>25</td> <td><code>File::readable_real?( path)</code></td> <td>如果 path 通过真正的用户权限是可读的，则返回 true。</td></tr> <tr><td>25</td> <td><code>File::readlink( path)</code></td> <td>返回 path 所指向的文件。</td></tr> <tr><td>26</td> <td><code>File::rename( old, new)</code></td> <td>改变文件名 old 为 new。</td></tr> <tr><td>27</td> <td><code>File::setgid?( path)</code></td> <td>如果设置了 path 的 set-group-id 权限位，则返回 true。</td></tr> <tr><td>28</td> <td><code>File::setuid?( path)</code></td> <td>如果设置了 path 的 set-user-id 权限位，则返回 true。</td></tr> <tr><td>29</td> <td><code>File::size( path)</code></td> <td>返回 path 的文件大小。</td></tr> <tr><td>30</td> <td><code>File::size?( path)</code></td> <td>返回 path 的文件大小，如果为 0 则返回 nil。</td></tr> <tr><td>31</td> <td><code>File::socket?( path)</code></td> <td>如果 path 是一个 socket，则返回 true。</td></tr> <tr><td>32</td> <td><code>File::split( path)</code></td> <td>返回一个数组，包含 path 的内容，path 被分成 File::dirname(path) 和 File::basename(path)。</td></tr> <tr><td>33</td> <td><code>File::stat( path)</code></td> <td>返回 path 上带有信息的 File::Stat 对象。</td></tr> <tr><td>34</td> <td><code>File::sticky?( path)</code></td> <td>如果设置了 path 的 sticky 位，则返回 true。</td></tr> <tr><td>35</td> <td><code>File::symlink( old, new)</code></td> <td>创建一个指向文件 old 的符号链接。</td></tr> <tr><td>36</td> <td><code>File::symlink?( path)</code></td> <td>如果 path 是一个符号链接，则返回 true。</td></tr> <tr><td>37</td> <td><code>File::truncate( path, len)</code></td> <td>截断指定的文件为 len 字节。</td></tr> <tr><td>38</td> <td><code>File::unlink( path...)</code></td> <td>删除 path 给定的文件。</td></tr> <tr><td>39</td> <td><code>File::umask([ mask])</code></td> <td>如果未指定参数，则为该进程返回当前的 umask。如果指定了一个参数，则设置了 umask，并返回旧的 umask。</td></tr> <tr><td>40</td> <td><code>File::utime( atime, mtime, path...)</code></td> <td>改变指定文件的访问和修改时间。</td></tr> <tr><td>41</td> <td><code>File::writable?( path)</code></td> <td>如果 path 是可写的，则返回 true。</td></tr> <tr><td>42</td> <td><code>File::writable_real?( path)</code></td> <td>如果 path 通过真正的用户权限是可写的，则返回 true。</td></tr> <tr><td>43</td> <td><code>File::zero?( path)</code></td> <td>如果 path 的文件大小是 0，则返回 true。</td></tr></tbody></table> <p>2、实例方法</p> <p>假设 f 是 File 类的一个实例：</p> <table><thead><tr><th>序号</th> <th>方法</th> <th>描述</th></tr></thead> <tbody><tr><td>1</td> <td><code>f.atime</code></td> <td>返回 f 的最后访问时间。</td></tr> <tr><td>2</td> <td><code>f.chmode( mode)</code></td> <td>改变 f 的权限模式。</td></tr> <tr><td>3</td> <td><code>f.chown( owner, group)</code></td> <td>改变 f 的所有者和所属组。</td></tr> <tr><td>4</td> <td><code>f.ctime</code></td> <td>返回 f 的最后一个 inode 更改时间。</td></tr> <tr><td>5</td> <td><code>f.flock( op)</code></td> <td>调用 flock(2)。op 可以是 0 或一个逻辑值或 File 类常量 LOCK_EX、LOCK_NB、LOCK_SH 和 LOCK_UN。</td></tr> <tr><td>6</td> <td><code>f.lstat</code></td> <td>与 stat 相同，但是它返回自身符号链接上的信息，而不是所指向的文件。</td></tr> <tr><td>7</td> <td><code>f.mtime</code></td> <td>返回 f 的最后修改时间。</td></tr> <tr><td>8</td> <td><code>f.path</code></td> <td>返回用于创建 f 的路径名。</td></tr> <tr><td>9</td> <td><code>f.reopen( path[, mode=&quot;r&quot;])</code></td> <td>重新打开文件。</td></tr> <tr><td>10</td> <td><code>f.truncate( len)</code></td> <td>截断 f 为 len 字节。</td></tr></tbody></table> <h2 id="ruby-dir-类和方法"><a href="#ruby-dir-类和方法" class="header-anchor">#</a> Ruby Dir 类和方法</h2> <p>Dir 是一个表示用于给出操作系统中目录中的文件名的目录流。Dir 类也拥有与目录相关的操作，比如通配符文件名匹配、改变工作目录等。</p> <p>1、类方法</p> <table><thead><tr><th>序号</th> <th>方法</th> <th>描述</th></tr></thead> <tbody><tr><td>1</td> <td><code>Dir[pat] Dir::glob( pat)</code></td> <td>返回一个数组，包含与指定的通配符模式 pat 匹配的文件名：_ - 匹配包含 null 字符串的任意字符串 ** - 递归地匹配任意字符串? - 匹配任意单个字符[...] - 匹配封闭字符中的任意一个{a,b...} - 匹配字符串中的任意一个 Dir[&quot;foo._&quot;] # 匹配 &quot;foo.c&quot;、 &quot;foo.rb&quot; 等等 Dir[&quot;foo.?&quot;] # 匹配 &quot;foo.c&quot;、 &quot;foo.h&quot; 等等</td></tr> <tr><td>2</td> <td><code>Dir::chdir( path)</code></td> <td>改变当前目录。</td></tr> <tr><td>3</td> <td><code>Dir::chroot( path)</code></td> <td>改变根目录（只允许超级用户）。并不是在所有的平台上都可用。</td></tr> <tr><td>4</td> <td><code>Dir::delete( path)</code></td> <td>删除 path 指定的目录。目录必须是空的。</td></tr> <tr><td>5</td> <td><code>Dir::entries( path)</code></td> <td>返回一个数组，包含目录 path 中的文件名。</td></tr> <tr><td>6</td> <td><code>Dir::foreach( path) {| f| ...}</code></td> <td>为 path 指定的目录中的每个文件执行一次块。</td></tr> <tr><td>7</td> <td><code>Dir::getwd Dir::pwd</code></td> <td>返回当前目录。</td></tr> <tr><td>8</td> <td><code>Dir::mkdir( path[, mode=0777])</code></td> <td>创建 path 指定的目录。权限模式可被 File::umask 的值修改，在 Win32 的平台上会被忽略。</td></tr> <tr><td>9</td> <td><code>Dir::new( path) Dir::open( path) Dir::open( path) {| dir| ...}</code></td> <td>返回 path 的新目录对象。如果 open 给出一个块，则新目录对象会传到该块，块会在终止前关闭目录对象。</td></tr> <tr><td>10</td> <td><code>Dir::pwd</code></td> <td>参见 Dir::getwd。</td></tr> <tr><td>11</td> <td><code>Dir::rmdir( path) Dir::unlink( path) Dir::delete( path)</code></td> <td>删除 path 指定的目录。目录必须是空的。</td></tr></tbody></table> <p>2、实例方法</p> <p>假设 d 是 Dir 类的一个实例：</p> <table><thead><tr><th>序号</th> <th>方法</th> <th>描述</th></tr></thead> <tbody><tr><td>1</td> <td><code>d.close</code></td> <td>关闭目录流。</td></tr> <tr><td>2</td> <td><code>d.each {| f| ...}</code></td> <td>为 d 中的每一个条目执行一次块。</td></tr> <tr><td>3</td> <td><code>d.pos d.tell</code></td> <td>返回 d 中的当前位置。</td></tr> <tr><td>4</td> <td><code>d.pos= offset</code></td> <td>设置目录流中的位置。</td></tr> <tr><td>5</td> <td><code>d.pos= pos d.seek(pos)</code></td> <td>移动到 d 中的某个位置。pos 必须是一个由 d.pos 返回的值或 0。</td></tr> <tr><td>6</td> <td><code>d.read</code></td> <td>返回 d 的下一个条目。</td></tr> <tr><td>7</td> <td><code>d.rewind</code></td> <td>移动 d 中的位置到第一个条目。</td></tr> <tr><td>8</td> <td><code>d.seek(po s)</code></td> <td>参见 d.pos=pos。</td></tr> <tr><td>9</td> <td><code>d.tell</code></td> <td>参见 d.pos。</td></tr></tbody></table> <h2 id="ruby-cgi-编程"><a href="#ruby-cgi-编程" class="header-anchor">#</a> Ruby CGI 编程</h2> <p>1、CGI 方法</p> <p>2、CGI Cookie</p> <p>3、CGI Session</p> <p>4、CGI 实例</p> <h2 id="ruby-编码类型转换"><a href="#ruby-编码类型转换" class="header-anchor">#</a> Ruby 编码类型转换</h2> <p>Ruby1.9 之后，我们可以直接通过使用 String 类的实例方法 encoding, force_encoding, encode, encode!进行相关的编码操作。</p> <p>本文重点参考了 Ruby 安装目录：/share/doc/ruby/html/String.html 中对字符编码转换方法的相关说明。</p> <p>我们可以通过以下方法，对字符类型进行编码转换：</p> <p>1、使用 <code>encode</code> 方法，返回字符串</p> <div class="language-rb extra-class"><pre class="language-rb"><code>encode<span class="token punctuation">(</span>encoding <span class="token punctuation">[</span><span class="token punctuation">,</span> options<span class="token punctuation">]</span> <span class="token punctuation">)</span> → str
encode<span class="token punctuation">(</span>dst_encoding<span class="token punctuation">,</span> src_encoding <span class="token punctuation">[</span><span class="token punctuation">,</span> options<span class="token punctuation">]</span> <span class="token punctuation">)</span> → str
encode<span class="token punctuation">(</span><span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">)</span> → str
</code></pre></div><p>第一个表单返回一个已转码的 str 的副本进行编码。第二个表单返回从 src_encoding 转码到 dst_encoding 的 str 的副本。最后一个表单返回一个已转码的 str 的副本，转码类型为：<code>Encoding.default_internal</code>.。</p> <p>默认情况下，第一种和第二种形式为目标编码中未定义的字符引发<code>Encoding::UndefinedConversionError</code>，以及源编码中无效的字节序列引发<code>Encoding::InvalidByteSequenceError</code>。默认情况下，最后一种不会引发异常，而是使用替换字符串。</p> <p><code>options</code> Hash 值给出了可以通过 <code>keys</code> 描述更多的转换细节：</p> <table><thead><tr><th>keys</th> <th>描述</th></tr></thead> <tbody><tr><td>:invald</td> <td>如果值是:replace, encode 将用替换字符替换 str 中无效的字节序列。默认情况下是引发<code>Encoding::InvalidByteSequenceError</code>异常。</td></tr> <tr><td>:undef</td> <td>如果值是:replace, encode 将用替换字符替换目标编码中未定义的字符。默认情况下是引发编码<code>Encoding::UndefinedConversionError</code>。</td></tr> <tr><td>:replace</td> <td>将替换字符串设置为给定值。默认的替换字符串是 Unicode 编码格式的“uFFFD”，以及“?”。</td></tr> <tr><td>:fallback</td> <td>根据给定对象为未定义字符设置替换字符串。对象应该是一个 Hash、一个 Proc、一个方法或一个具有[]方法的对象。它的键是在当前转码器的源编码中编码的未定义字符。它的值可以是任何编码，直到可以转换为转码器的目标编码为止。</td></tr> <tr><td>:xml</td> <td>值必须是 <code>:text</code> 或者 <code>:attr</code>。 如果值为 <code>:text</code> <code>encode</code> 用(大写十六进制)数字字符引用替换未定义的字符。<code>'&amp;'</code>, <code>'&lt;'</code>, 和 <code>'&gt;'</code> 将被分别替换为 <code>“&amp;amp;”</code>, <code>“&amp;lt;”</code>, 和 <code>“&amp;gt;”</code>。 如果值为 <code>:attr</code>, encode 也将引用替换结果 (using '“'), 并将 '”' 替换为 “&quot;”.</td></tr> <tr><td>:cr_newline</td> <td>如果值为真，则将 LF (&quot; n &quot;)替换为 CR (&quot; r &quot;)。</td></tr> <tr><td>:crlf_newline</td> <td>如果值为真，则用 CRLF (&quot; rn &quot;)替换 LF (&quot; n &quot;)。</td></tr> <tr><td>:universal_newline</td> <td>如果值为真，将 CRLF (&quot; rn &quot;)和 CR (&quot; r &quot;)替换为 LF (&quot; n &quot;)。</td></tr></tbody></table> <p>2、使用 <code>encode!</code> 方法，返回字符串</p> <div class="language-rb extra-class"><pre class="language-rb"><code>encode<span class="token operator">!</span><span class="token punctuation">(</span>encoding <span class="token punctuation">[</span><span class="token punctuation">,</span> options<span class="token punctuation">]</span> <span class="token punctuation">)</span> → str
encode<span class="token operator">!</span><span class="token punctuation">(</span>dst_encoding<span class="token punctuation">,</span> src_encoding <span class="token punctuation">[</span><span class="token punctuation">,</span> options<span class="token punctuation">]</span> <span class="token punctuation">)</span> → str
</code></pre></div><p>第一种格式将 str 的内容从 str.encoding 转换为 encoding。第二种格式将 str 的内容从 src_encoding 转换为 dst_encoding。options 哈希给出了转换的详细信息。有关详细信息，请参见字符串#encode。即使没有进行任何更改，也返回该字符串。</p> <p>方法定义：</p> <div class="language-rb extra-class"><pre class="language-rb"><code>static <span class="token constant">VALUE</span>
str_encode_bang<span class="token punctuation">(</span>int argc<span class="token punctuation">,</span> <span class="token constant">VALUE</span> <span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token constant">VALUE</span> str<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token constant">VALUE</span> newstr<span class="token punctuation">;</span>
    int encidx<span class="token punctuation">;</span>

    rb_check_frozen<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>

    newstr <span class="token operator">=</span> str<span class="token punctuation">;</span>
    encidx <span class="token operator">=</span> str_transcode<span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token operator">&amp;</span>newstr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>encidx <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> str<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newstr <span class="token operator">==</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rb_enc_associate_index<span class="token punctuation">(</span>str<span class="token punctuation">,</span> encidx<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> str<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    rb_str_shared_replace<span class="token punctuation">(</span>str<span class="token punctuation">,</span> newstr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> str_encode_associate<span class="token punctuation">(</span>str<span class="token punctuation">,</span> encidx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>3、使用 <code>encoding</code> 方法，返回 encoding</p> <div class="language-rb extra-class"><pre class="language-rb"><code>encoding → encoding    <span class="token comment"># 返回表示obj编码的编码对象。</span>
</code></pre></div><p>方法定义：</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token constant">VALUE</span>
rb_obj_encoding<span class="token punctuation">(</span><span class="token constant">VALUE</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    int idx <span class="token operator">=</span> rb_enc_get_index<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	rb_raise<span class="token punctuation">(</span>rb_eTypeError<span class="token punctuation">,</span> <span class="token string">&quot;unknown encoding&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> rb_enc_from_encoding_index<span class="token punctuation">(</span>idx <span class="token operator">&amp;</span> <span class="token constant">ENC_INDEX_MASK</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>4、使用 <code>force_encoding</code> 方法，返回字符串</p> <div class="language-rb extra-class"><pre class="language-rb"><code>force_encoding<span class="token punctuation">(</span>encoding<span class="token punctuation">)</span> → str   <span class="token comment"># 将编码更改为encoding并返回self。</span>
</code></pre></div><p>方法定义：</p> <div class="language-rb extra-class"><pre class="language-rb"><code>static <span class="token constant">VALUE</span>
rb_str_force_encoding<span class="token punctuation">(</span><span class="token constant">VALUE</span> str<span class="token punctuation">,</span> <span class="token constant">VALUE</span> enc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    str_modifiable<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    rb_enc_associate<span class="token punctuation">(</span>str<span class="token punctuation">,</span> rb_to_encoding<span class="token punctuation">(</span>enc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token constant">ENC_CODERANGE_CLEAR</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>5、使用 <code>valid_encoding</code> ,验证字符串编码是否正确</p> <div class="language-rb extra-class"><pre class="language-rb"><code>valid_encoding<span class="token operator">?</span> → <span class="token boolean">true</span> <span class="token keyword">or</span> <span class="token boolean">false</span>   <span class="token comment"># 对于正确编码的字符串返回true。</span>
</code></pre></div><p>方法定义：</p> <div class="language-rb extra-class"><pre class="language-rb"><code>static <span class="token constant">VALUE</span>
rb_str_valid_encoding_p<span class="token punctuation">(</span><span class="token constant">VALUE</span> str<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    int cr <span class="token operator">=</span> rb_enc_str_coderange<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> cr <span class="token operator">==</span> <span class="token constant">ENC_CODERANGE_BROKEN</span> <span class="token operator">?</span> <span class="token constant">Qfalse</span> <span class="token punctuation">:</span> <span class="token constant">Qtrue</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实例：</p> <div class="language-rb extra-class"><pre class="language-rb"><code><span class="token string">&quot;\xc2\xa1&quot;</span><span class="token punctuation">.</span>force_encoding<span class="token punctuation">(</span><span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>valid_encoding<span class="token operator">?</span>  <span class="token comment">#=&gt; true</span>
<span class="token string">&quot;\xc2&quot;</span><span class="token punctuation">.</span>force_encoding<span class="token punctuation">(</span><span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>valid_encoding<span class="token operator">?</span>      <span class="token comment">#=&gt; false</span>
<span class="token string">&quot;\x80&quot;</span><span class="token punctuation">.</span>force_encoding<span class="token punctuation">(</span><span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>valid_encoding<span class="token operator">?</span>      <span class="token comment">#=&gt; false</span>
</code></pre></div></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/devdiv/school/edit/master/docs/develop/ruby.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">5/10/2020, 6:26:27 PM</span></div></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/school/develop/Rails.html" class="prev">
          Rails
        </a></span> <span class="next"><a href="/school/develop/vue.html">
          Vue
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/school/assets/js/app.5919148e.js" defer></script><script src="/school/assets/js/89.43b51396.js" defer></script>
  </body>
</html>
